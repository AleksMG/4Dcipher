<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D S-Box Crypto System</title>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #1e40af;
            --accent: #3b82f6;
            --dark: #1e293b;
            --light: #f8fafc;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, var(--accent), var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--primary);
        }
        
        .panel-header h2 {
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--accent);
        }
        
        textarea, input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(15, 23, 42, 0.6);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            color: var(--light);
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 20px 0;
        }
        
        button {
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .result-area {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            border: 2px solid rgba(59, 130, 246, 0.3);
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-success {
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--success);
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error);
        }
        
        .status-warning {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning);
        }
        
        /* –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è */
        .visualization {
            margin-top: 30px;
        }
        
        .rounds-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .round {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid var(--accent);
            transition: all 0.3s ease;
        }
        
        .round.active {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
        }
        
        .sbox-visualization {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .sbox-layer {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .sbox-title {
            text-align: center;
            margin-bottom: 10px;
            color: var(--accent);
            font-weight: 600;
        }
        
        .sbox-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
        }
        
        .sbox-cell {
            width: 20px;
            height: 20px;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .sbox-cell:hover {
            background: rgba(59, 130, 246, 0.3);
            transform: scale(1.3);
        }
        
        .sbox-cell.active {
            background: var(--primary);
            color: white;
            font-weight: bold;
        }
        
        .bit-visualization {
            margin-top: 25px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .bit-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .bit {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .bit.one {
            background: var(--primary);
            color: white;
        }
        
        .integrity-check {
            margin-top: 25px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .integrity-result {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
        }
        
        .integrity-valid {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
        }
        
        .integrity-invalid {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }
        
        .processing-animation {
            margin-top: 20px;
            height: 4px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }
        
        .processing-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            transition: width 0.5s ease;
        }
        
        .hash-display {
            margin-top: 20px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>3D S-Box Crypto System</h1>
            <p>–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Å –ø–æ–ª–Ω–æ–π –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞</p>
        </header>

        <div class="main-grid">
            <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
            <div class="panel">
                <div class="panel-header">
                    <h2>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º</h2>
                </div>
                
                <div class="form-group">
                    <label for="inputText">–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç / –®–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç:</label>
                    <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∏–ª–∏ HEX-—à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è..."></textarea>
                </div>
                
                <div class="form-group">
                    <label for="encryptionKey">–ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (–º–∏–Ω. 12 —Å–∏–º–≤–æ–ª–æ–≤):</label>
                    <input type="password" id="encryptionKey" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á...">
                </div>
                
                <div class="btn-group">
                    <button class="btn-primary" onclick="startEncryption()">
                        <span>üîí</span> –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
                    </button>
                    <button class="btn-primary" onclick="startDecryption()">
                        <span>üîì</span> –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
                    </button>
                    <button class="btn-secondary" onclick="generateKey()">
                        <span>üé≤</span> –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á
                    </button>
                    <button class="btn-secondary" onclick="clearAll()">
                        <span>üßπ</span> –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë
                    </button>
                </div>
                
                <div class="result-area" id="resultArea">
                    –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–ø–µ—Ä–∞—Ü–∏–π –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω—ã –∑–¥–µ—Å—å...
                </div>
                
                <div class="status status-warning" id="statusMessage">
                    <span>‚ö†Ô∏è</span> –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ. –í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–∞—á–∞–ª–∞.
                </div>
                
                <div class="processing-animation">
                    <div class="processing-bar" id="processingBar"></div>
                </div>
            </div>
            
            <!-- –ü–∞–Ω–µ–ª—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ -->
            <div class="panel">
                <div class="panel-header">
                    <h2>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞</h2>
                </div>
                
                <div class="visualization">
                    <h3>–†–∞—É–Ω–¥—ã —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h3>
                    <div class="rounds-container" id="roundsContainer">
                        <!-- –†–∞—É–Ω–¥—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ JS -->
                    </div>
                    
                    <h3>3D S-Box –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ</h3>
                    <div class="sbox-visualization">
                        <div class="sbox-layer">
                            <div class="sbox-title">S-Box X</div>
                            <div class="sbox-grid" id="sboxX">
                                <!-- –Ø—á–µ–π–∫–∏ S-Box X -->
                            </div>
                        </div>
                        <div class="sbox-layer">
                            <div class="sbox-title">S-Box Y</div>
                            <div class="sbox-grid" id="sboxY">
                                <!-- –Ø—á–µ–π–∫–∏ S-Box Y -->
                            </div>
                        </div>
                        <div class="sbox-layer">
                            <div class="sbox-title">S-Box Z</div>
                            <div class="sbox-grid" id="sboxZ">
                                <!-- –Ø—á–µ–π–∫–∏ S-Box Z -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="bit-visualization">
                        <h3>–ë–∏—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ</h3>
                        <div class="bit-grid" id="bitGrid">
                            <!-- –ë–∏—Ç—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ JS -->
                        </div>
                    </div>
                    
                    <div class="integrity-check">
                        <h3>–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏</h3>
                        <div class="integrity-result" id="integrityResult">
                            <span>üîç</span> –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ –ø—Ä–æ–≤–æ–¥–∏–ª–∞—Å—å
                        </div>
                    </div>
                    
                    <div class="hash-display" id="hashDisplay">
                        –•–µ—à: _________________________
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
        const CONFIG = {
            ROUNDS: 12,
            KEY_MIN_LENGTH: 12,
            BLOCK_SIZE: 64,
            ANIMATION_DELAY: 100
        };
        
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let currentRound = 0;
        let isProcessing = false;
        let sBoxSets = [];
        let integrityHash = '';
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        function initializeVisualization() {
            // –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Ä–∞—É–Ω–¥–æ–≤
            const roundsContainer = document.getElementById('roundsContainer');
            roundsContainer.innerHTML = '';
            
            for (let i = 1; i <= CONFIG.ROUNDS; i++) {
                const round = document.createElement('div');
                round.className = 'round';
                round.textContent = i;
                round.id = `round-${i}`;
                roundsContainer.appendChild(round);
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º S-Box –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
            initializeSBoxVisualization();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∏—Ç–æ–≤—É—é –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
            initializeBitVisualization();
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è S-Box –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        function initializeSBoxVisualization() {
            const sboxX = document.getElementById('sboxX');
            const sboxY = document.getElementById('sboxY');
            const sboxZ = document.getElementById('sboxZ');
            
            sboxX.innerHTML = '';
            sboxY.innerHTML = '';
            sboxZ.innerHTML = '';
            
            for (let i = 0; i < 256; i++) {
                const cellX = createSBoxCell(i);
                const cellY = createSBoxCell(i);
                const cellZ = createSBoxCell(i);
                
                sboxX.appendChild(cellX);
                sboxY.appendChild(cellY);
                sboxZ.appendChild(cellZ);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —è—á–µ–π–∫–∏ S-Box
        function createSBoxCell(value) {
            const cell = document.createElement('div');
            cell.className = 'sbox-cell';
            cell.textContent = value.toString(16).padStart(2, '0').toUpperCase();
            cell.title = `–ó–Ω–∞—á–µ–Ω–∏–µ: ${value}`;
            return cell;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∏—Ç–æ–≤–æ–π –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        function initializeBitVisualization() {
            const bitGrid = document.getElementById('bitGrid');
            bitGrid.innerHTML = '';
            
            for (let i = 7; i >= 0; i--) {
                const bit = document.createElement('div');
                bit.className = 'bit';
                bit.textContent = '0';
                bit.dataset.bit = i;
                bitGrid.appendChild(bit);
            }
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è S-Box –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
        function generateSBoxes(key) {
            sBoxSets = [];
            
            for (let round = 0; round < CONFIG.ROUNDS; round++) {
                const roundKey = key + round.toString();
                const seed = hashString(roundKey);
                
                const sBoxSet = {
                    x: generateSBoxLayer(seed),
                    y: generateSBoxLayer(seed + 1),
                    z: generateSBoxLayer(seed + 2)
                };
                
                sBoxSets.push(sBoxSet);
            }
            
            return sBoxSets;
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–¥–Ω–æ–≥–æ —Å–ª–æ—è S-Box
        function generateSBoxLayer(seed) {
            const sbox = new Array(256);
            for (let i = 0; i < 256; i++) sbox[i] = i;
            
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ seed
            let state = seed;
            for (let i = 255; i > 0; i--) {
                state = (state * 1664525 + 1013904223) % 4294967296;
                const j = state % (i + 1);
                [sbox[i], sbox[j]] = [sbox[j], sbox[i]];
            }
            
            return sbox;
        }
        
        // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash);
        }
        
        // –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
        async function encryptData(text, key) {
            if (isProcessing) return;
            isProcessing = true;
            
            try {
                updateStatus('–ù–∞—á–∞–ª–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...', 'warning');
                updateProgress(0);
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º S-Box
                generateSBoxes(key);
                updateProgress(10);
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–µ–∫—Å—Ç –≤ –±–∞–π—Ç—ã
                const textBytes = new TextEncoder().encode(text);
                integrityHash = calculateHash(textBytes);
                updateHashDisplay(integrityHash);
                
                updateStatus('–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ 3D S-Box –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π...', 'warning');
                
                const resultBytes = new Uint8Array(textBytes.length);
                
                // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º —Ä–∞—É–Ω–¥–∞–º
                for (let round = 0; round < CONFIG.ROUNDS; round++) {
                    currentRound = round + 1;
                    updateRoundIndicator(currentRound);
                    updateProgress(10 + (round * 70 / CONFIG.ROUNDS));
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π S-Box
                    visualizeSBoxes(round);
                    
                    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –±–∞–π—Ç
                    for (let i = 0; i < textBytes.length; i++) {
                        let byte = textBytes[i];
                        
                        // –ü—Ä–∏–º–µ–Ω—è–µ–º S-Box –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
                        byte = sBoxSets[round].x[byte];
                        byte = sBoxSets[round].y[byte];
                        byte = sBoxSets[round].z[byte];
                        
                        resultBytes[i] = byte;
                        
                        // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∏—Ç—ã
                        if (i === 0) visualizeBits(byte);
                        
                        await delay(CONFIG.ANIMATION_DELAY / textBytes.length);
                    }
                    
                    await delay(300);
                }
                
                updateProgress(80);
                updateStatus('–§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞...', 'warning');
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ HEX
                const hexResult = bytesToHex(resultBytes);
                
                updateProgress(100);
                updateStatus('–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!', 'success');
                updateIntegrityCheck(true);
                
                return hexResult;
                
            } catch (error) {
                updateStatus(`–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ${error.message}`, 'error');
                return null;
            } finally {
                isProcessing = false;
            }
        }
        
        // –ü—Ä–æ—Ü–µ—Å—Å –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
        async function decryptData(hexData, key) {
            if (isProcessing) return;
            isProcessing = true;
            
            try {
                updateStatus('–ù–∞—á–∞–ª–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...', 'warning');
                updateProgress(0);
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º S-Box
                generateSBoxes(key);
                updateProgress(10);
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEX –≤ –±–∞–π—Ç—ã
                const encryptedBytes = hexToBytes(hexData);
                
                updateStatus('–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω—ã—Ö 3D S-Box –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π...', 'warning');
                
                const resultBytes = new Uint8Array(encryptedBytes.length);
                
                // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º —Ä–∞—É–Ω–¥–∞–º –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
                for (let round = CONFIG.ROUNDS - 1; round >= 0; round--) {
                    currentRound = CONFIG.ROUNDS - round;
                    updateRoundIndicator(currentRound);
                    updateProgress(10 + ((CONFIG.ROUNDS - round - 1) * 70 / CONFIG.ROUNDS));
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π S-Box
                    visualizeSBoxes(round);
                    
                    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –±–∞–π—Ç
                    for (let i = 0; i < encryptedBytes.length; i++) {
                        let byte = encryptedBytes[i];
                        
                        // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—ã–µ S-Box –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
                        byte = sBoxSets[round].z.indexOf(byte);
                        byte = sBoxSets[round].y.indexOf(byte);
                        byte = sBoxSets[round].x.indexOf(byte);
                        
                        resultBytes[i] = byte;
                        
                        // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∏—Ç—ã
                        if (i === 0) visualizeBits(byte);
                        
                        await delay(CONFIG.ANIMATION_DELAY / encryptedBytes.length);
                    }
                    
                    await delay(300);
                }
                
                updateProgress(80);
                updateStatus('–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏...', 'warning');
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å
                const currentHash = calculateHash(resultBytes);
                const integrityValid = currentHash === integrityHash;
                
                updateProgress(100);
                
                if (integrityValid) {
                    updateStatus('–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!', 'success');
                    updateIntegrityCheck(true);
                    return new TextDecoder().decode(resultBytes);
                } else {
                    updateStatus('–û—à–∏–±–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö!', 'error');
                    updateIntegrityCheck(false);
                    return null;
                }
                
            } catch (error) {
                updateStatus(`–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ${error.message}`, 'error');
                return null;
            } finally {
                isProcessing = false;
            }
        }
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function bytesToHex(bytes) {
            return Array.from(bytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }
        
        function calculateHash(bytes) {
            let hash = 0;
            for (const byte of bytes) {
                hash = ((hash << 5) - hash) + byte;
                hash |= 0;
            }
            return hash.toString(16).padStart(8, '0');
        }
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UI
        function updateStatus(message, type) {
            const status = document.getElementById('statusMessage');
            status.className = `status status-${type}`;
            
            let icon = '‚ö†Ô∏è';
            if (type === 'success') icon = '‚úÖ';
            if (type === 'error') icon = '‚ùå';
            
            status.innerHTML = `<span>${icon}</span> ${message}`;
        }
        
        function updateProgress(percent) {
            const bar = document.getElementById('processingBar');
            bar.style.width = `${percent}%`;
        }
        
        function updateRoundIndicator(round) {
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ —Ä–∞—É–Ω–¥—ã
            document.querySelectorAll('.round').forEach(r => {
                r.classList.remove('active');
            });
            
            // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π —Ä–∞—É–Ω–¥
            const currentRoundElement = document.getElementById(`round-${round}`);
            if (currentRoundElement) {
                currentRoundElement.classList.add('active');
            }
        }
        
        function visualizeSBoxes(roundIndex) {
            if (roundIndex >= sBoxSets.length) return;
            
            const sboxSet = sBoxSets[roundIndex];
            
            // –û–±–Ω–æ–≤–ª—è–µ–º S-Box –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
            updateSBoxLayer('sboxX', sboxSet.x);
            updateSBoxLayer('sboxY', sboxSet.y);
            updateSBoxLayer('sboxZ', sboxSet.z);
        }
        
        function updateSBoxLayer(layerId, sbox) {
            const layer = document.getElementById(layerId);
            const cells = layer.querySelectorAll('.sbox-cell');
            
            for (let i = 0; i < Math.min(sbox.length, cells.length); i++) {
                cells[i].textContent = sbox[i].toString(16).padStart(2, '0').toUpperCase();
                cells[i].title = `–ò–Ω–¥–µ–∫—Å: ${i.toString(16).padStart(2, '0').toUpperCase()}\n–ó–Ω–∞—á–µ–Ω–∏–µ: ${sbox[i].toString(16).padStart(2, '0').toUpperCase()}`;
            }
        }
        
        function visualizeBits(byte) {
            const bits = document.querySelectorAll('.bit');
            
            for (let i = 0; i < 8; i++) {
                const bitValue = (byte >> (7 - i)) & 1;
                bits[i].textContent = bitValue;
                bits[i].className = `bit ${bitValue ? 'one' : ''}`;
            }
        }
        
        function updateIntegrityCheck(isValid) {
            const integrityResult = document.getElementById('integrityResult');
            integrityResult.className = `integrity-result ${isValid ? 'integrity-valid' : 'integrity-invalid'}`;
            
            if (isValid) {
                integrityResult.innerHTML = '<span>‚úÖ</span> –¶–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞';
            } else {
                integrityResult.innerHTML = '<span>‚ùå</span> –ù–∞—Ä—É—à–µ–Ω–∏–µ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö!';
            }
        }
        
        function updateHashDisplay(hash) {
            document.getElementById('hashDisplay').textContent = `–•–µ—à: ${hash}`;
        }
        
        function updateResult(content) {
            document.getElementById('resultArea').textContent = content;
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π
        async function startEncryption() {
            const text = document.getElementById('inputText').value;
            const key = document.getElementById('encryptionKey').value;
            
            if (!text) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }
            
            if (!key || key.length < CONFIG.KEY_MIN_LENGTH) {
                updateStatus(`–ö–ª—é—á –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º ${CONFIG.KEY_MIN_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤`, 'error');
                return;
            }
            
            initializeVisualization();
            const result = await encryptData(text, key);
            
            if (result) {
                updateResult(`–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (HEX):\n${result}`);
            }
        }
        
        async function startDecryption() {
            const text = document.getElementById('inputText').value;
            const key = document.getElementById('encryptionKey').value;
            
            if (!text) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }
            
            if (!key || key.length < CONFIG.KEY_MIN_LENGTH) {
                updateStatus(`–ö–ª—é—á –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º ${CONFIG.KEY_MIN_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤`, 'error');
                return;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤–≤–æ–¥ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ HEX
            if (!/^[0-9a-fA-F]+$/.test(text)) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π HEX-—à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç', 'error');
                return;
            }
            
            initializeVisualization();
            const result = await decryptData(text, key);
            
            if (result) {
                updateResult(`–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:\n${result}`);
            }
        }
        
        function generateKey() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_-+=[]{}|;:,.<>?';
            let key = '';
            
            for (let i = 0; i < 24; i++) {
                key += chars[Math.floor(Math.random() * chars.length)];
            }
            
            document.getElementById('encryptionKey').value = key;
            updateStatus('–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –Ω–æ–≤—ã–π –∫–ª—é—á', 'success');
        }
        
        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('encryptionKey').value = '';
            document.getElementById('resultArea').textContent = '–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–ø–µ—Ä–∞—Ü–∏–π –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω—ã –∑–¥–µ—Å—å...';
            updateStatus('–í—Å–µ –ø–æ–ª—è –æ—á–∏—â–µ–Ω—ã. –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ.', 'warning');
            initializeVisualization();
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        document.addEventListener('DOMContentLoaded', function() {
            initializeVisualization();
            generateKey();
        });
    </script>
</body>
</html>
