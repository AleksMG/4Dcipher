<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key-Derived Homophonic Cipher</title>
    <style>
        :root {
            --primary: #1a365d;
            --secondary: #2a69ac;
            --accent: #e53e3e;
            --success: #38a169;
            --warning: #d69e2e;
            --light: #f7fafc;
            --dark: #2d3748;
            --border: #e2e8f0;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Fira Code', 'Courier New', monospace;
        }
        
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #0f172a 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1.6;
            color: #e2e8f0;
        }
        
        .container {
            background: rgba(26, 32, 44, 0.95);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            padding: 40px;
            width: 100%;
            max-width: 1400px;
            margin: 20px;
            border: 1px solid #2d3748;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }
        
        h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
            background: linear-gradient(45deg, #63b3ed, #4299e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 968px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: #2d3748;
            border-radius: 12px;
            padding: 28px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #4a5568;
        }
        
        .card h3 {
            color: white;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .input-group {
            margin-bottom: 24px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e2e8f0;
            font-size: 0.95em;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 14px;
            border: 2px solid #4a5568;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
            background: #1a202c;
            color: #e2e8f0;
            font-family: 'Fira Code', monospace;
        }
        
        input:focus, textarea:focus, select:focus {
            border-color: #4299e1;
            outline: none;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }
        
        textarea {
            min-height: 140px;
            resize: vertical;
            line-height: 1.5;
        }
        
        .btn-group {
            display: flex;
            gap: 16px;
            margin: 28px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 140px;
        }
        
        .btn-encrypt {
            background: linear-gradient(45deg, #2b6cb0, #2c5282);
            color: white;
        }
        
        .btn-decrypt {
            background: linear-gradient(45deg, #e53e3e, #c53030);
            color: white;
        }
        
        .btn-generate {
            background: linear-gradient(45deg, #38a169, #2f855a);
            color: white;
        }
        
        .security-badge {
            display: inline-block;
            padding: 6px 12px;
            background: linear-gradient(45deg, #38a169, #2f855a);
            color: white;
            border-radius: 16px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }
        
        .metric-card {
            background: #1a202c;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #4a5568;
        }
        
        .metric-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #63b3ed;
            margin: 8px 0;
        }
        
        .result-content {
            background: #1a202c;
            padding: 16px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.5;
        }
        
        .homophone-table {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .homophone-item {
            background: #1a202c;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            font-size: 0.8em;
        }
        
        .homophone-char {
            font-weight: bold;
            color: #63b3ed;
        }
        
        .warning {
            background: #742a2a;
            border: 1px solid #e53e3e;
            color: #fed7d7;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 0.9em;
        }
        
        .icon {
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Key-Derived Homophonic Cipher</h1>
            <p class="subtitle">–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–º–æ—Ñ–æ–Ω–æ–≤ –∏–∑ –∫–ª—é—á–∞ ‚Ä¢ AES-256-GCM ‚Ä¢ –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è</p>
        </div>

        <div class="warning">
            <strong>‚ö†Ô∏è –í–ê–ñ–ù–û:</strong> –≠—Ç–æ —É—á–µ–±–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è. –î–ª—è production –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–±–∏–±–ª–∏–æ—Ç–µ–∫–∏.
        </div>

        <div class="grid">
            <div class="card">
                <h3><span class="icon">üîë</span> –ö–ª—é—á–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞</h3>
                <div class="input-group">
                    <label for="masterKey">–ú–∞—Å—Ç–µ—Ä-–∫–ª—é—á (–ª—é–±–∞—è —Å—Ç—Ä–æ–∫–∞):</label>
                    <input type="text" id="masterKey" value="–°–µ–∫—Ä–µ—Ç–Ω—ã–π–ö–ª—é—á2024!" placeholder="–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á">
                </div>
                
                <div class="input-group">
                    <label for="homophoneCount">–ë–∞–∑–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–º–æ—Ñ–æ–Ω–æ–≤:</label>
                    <select id="homophoneCount">
                        <option value="3">3 –æ–º–æ—Ñ–æ–Ω–∞ (~1.58 –±–∏—Ç/—Å–∏–º–≤–æ–ª)</option>
                        <option value="5" selected>5 –æ–º–æ—Ñ–æ–Ω–æ–≤ (~2.32 –±–∏—Ç/—Å–∏–º–≤–æ–ª)</option>
                        <option value="7">7 –æ–º–æ—Ñ–æ–Ω–æ–≤ (~2.81 –±–∏—Ç/—Å–∏–º–≤–æ–ª)</option>
                        <option value="10">10 –æ–º–æ—Ñ–æ–Ω–æ–≤ (~3.32 –±–∏—Ç/—Å–∏–º–≤–æ–ª)</option>
                    </select>
                </div>
                
                <button class="btn-generate" onclick="generateNewKey()">
                    <span class="icon">üé≤</span> –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á
                </button>
            </div>

            <div class="card">
                <h3><span class="icon">üìù</span> –¢–µ–∫—Å—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏</h3>
                <div class="input-group">
                    <label for="inputText">–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:</label>
                    <textarea id="inputText">–°–µ–∫—Ä–µ—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —É—Å–∏–ª–µ–Ω–Ω–æ–≥–æ –æ–º–æ—Ñ–æ–Ω–Ω–æ–≥–æ —à–∏—Ñ—Ä–∞ —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π —Ç–∞–±–ª–∏—Ü –∏–∑ –∫–ª—é—á–∞</textarea>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">–î–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞</div>
                        <div class="metric-value" id="textLength">0</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">–≠–Ω—Ç—Ä–æ–ø–∏—è</div>
                        <div class="metric-value" id="textEntropy">0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group">
            <button class="btn-encrypt" onclick="encryptText()">
                <span class="icon">üîí</span> –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
            </button>
            <button class="btn-decrypt" onclick="decryptText()">
                <span class="icon">üîì</span> –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
            </button>
        </div>

        <div class="grid">
            <div class="card">
                <h3><span class="icon">üìä</span> –†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
                <div class="input-group">
                    <label for="outputText">–û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</label>
                    <textarea id="outputText" readonly placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..."></textarea>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">–†–∞–∑–º–µ—Ä</div>
                        <div class="metric-value" id="resultSize">0 B</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">–≠–Ω—Ç—Ä–æ–ø–∏—è</div>
                        <div class="metric-value" id="resultEntropy">0.00</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3><span class="icon">üîÑ</span> –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Ç–∞–±–ª–∏—Ü–∞ –æ–º–æ—Ñ–æ–Ω–æ–≤</h3>
                <div class="input-group">
                    <label>–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–º–æ—Ñ–æ–Ω—ã (–ø–µ—Ä–≤—ã–µ 20):</label>
                    <div class="homophone-table" id="homophoneTablePreview">
                        <div class="homophone-item">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    </div>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">–°–∏–º–≤–æ–ª–æ–≤</div>
                        <div class="metric-value" id="tableSize">0</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">–£–Ω–∏–∫. –æ–º–æ—Ñ–æ–Ω–æ–≤</div>
                        <div class="metric-value" id="uniqueHomophones">0</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3><span class="icon">üîç</span> –ö—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑</h3>
            <div class="grid">
                <div class="input-group">
                    <label>–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞:</label>
                    <div class="result-content" id="frequencyOriginal">...</div>
                </div>
                <div class="input-group">
                    <label>–ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:</label>
                    <div class="result-content" id="frequencyResult">...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class KeyDerivedHomophonicCipher {
            constructor() {
                this.homophoneTable = new Map();
                this.baseAlphabet = "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—èABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                this.homophonePool = this.generateHomophonePool();
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—É–ª–∞ –æ–º–æ—Ñ–æ–Ω–æ–≤ (2048 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤)
            generateHomophonePool() {
                const pool = new Set();
                // –î–∏–∞–ø–∞–∑–æ–Ω—ã Unicode –¥–ª—è –æ–º–æ—Ñ–æ–Ω–æ–≤
                const ranges = [
                    [0x0400, 0x04FF],   // –ö–∏—Ä–∏–ª–ª–∏—Ü–∞
                    [0x0370, 0x03FF],   // –ì—Ä–µ—á–µ—Å–∫–∏–π –∏ –ö–æ–ø—Ç—Å–∫–∏–π
                    [0x2000, 0x206F],   // –ü—É–Ω–∫—Ç—É–∞—Ü–∏—è
                    [0x2100, 0x214F],   // –ë—É–∫–≤–æ–ø–æ–¥–æ–±–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                    [0x2150, 0x218F],   // –ß–∏—Å–ª–æ–≤—ã–µ —Ñ–æ—Ä–º—ã
                    [0x2190, 0x21FF],   // –°—Ç—Ä–µ–ª–∫–∏
                    [0x2200, 0x22FF],   // –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã
                    [0x2300, 0x23FF],   // –†–∞–∑–Ω—ã–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ
                    [0x2460, 0x24FF],   // –û–±—Ä–∞–º–ª–µ–Ω–Ω—ã–µ –±—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã
                    [0x2580, 0x259F],   // –ë–ª–æ–∫–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
                    [0x25A0, 0x25FF],   // –ì–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ —Ñ–∏–≥—É—Ä—ã
                    [0x2600, 0x26FF],   // –†–∞–∑–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                    [0x2700, 0x27BF],   // Dingbats
                    [0x27C0, 0x27EF],   // –†–∞–∑–Ω—ã–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ
                    [0x27F0, 0x27FF],   // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–µ–ª–∫–∏
                    [0x2900, 0x297F],   // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–µ–ª–∫–∏-B
                    [0x2980, 0x29FF],   // –†–∞–∑–Ω—ã–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ-B
                    [0x2A00, 0x2AFF],   // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ
                    [0x2B00, 0x2BFF],   // –†–∞–∑–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏ —Å—Ç—Ä–µ–ª–∫–∏
                    [0x3000, 0x303F],   // –ö–∏—Ç–∞–π—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã
                    [0x3040, 0x309F],   // –•–∏—Ä–∞–≥–∞–Ω–∞
                    [0x30A0, 0x30FF],   // –ö–∞—Ç–∞–∫–∞–Ω–∞
                    [0x3100, 0x312F],   // –ë–æ–ø–æ–º–æ—Ñ–æ
                    [0x3130, 0x318F],   // –°–æ–≤–º–µ—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã –•–∞–Ω–≥—É–ª
                    [0x3190, 0x319F],   // –ö–∞–Ω–±—É–Ω
                    [0x31A0, 0x31BF],   // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –±–æ–ø–æ–º–æ—Ñ–æ
                    [0x31C0, 0x31EF],   // –ß–µ—Ä—Ç—ã –ö–ö–Ø
                    [0x31F0, 0x31FF],   // –§–æ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –∫–∞—Ç–∞–∫–∞–Ω—ã
                    [0x3200, 0x32FF],   // –û–±—Ä–∞–º–ª–µ–Ω–Ω—ã–µ –±—É–∫–≤—ã –∏ –º–µ—Å—è—Ü—ã
                    [0x3300, 0x33FF],   // –°–æ–≤–º–µ—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã –ö–ö–Ø
                    [0x3400, 0x4DBF],   // –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ê –∏–µ—Ä–æ–≥–ª–∏—Ñ–æ–≤ –ö–ö–Ø
                    [0x4E00, 0x9FFF],   // –ò–µ—Ä–æ–≥–ª–∏—Ñ—ã –ö–ö–Ø
                    [0xA000, 0xA48F],   // –°–ª–æ–≥–æ–≤–æ–µ –ø–∏—Å—å–º–æ –ò
                    [0xA490, 0xA4CF],   // –ö–≤–∞–¥—Ä–∞—Ç–Ω–æ–µ –ø–∏—Å—å–º–æ –ò
                    [0xFE30, 0xFE4F],   // –§–æ—Ä–º—ã —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ CJK
                    [0xFF00, 0xFFEF],   // –ü–æ–ª—É—à–∏—Ä–∏–Ω–Ω—ã–µ –∏ –ø–æ–ª–Ω–æ—à–∏—Ä–∏–Ω–Ω—ã–µ —Ñ–æ—Ä–º—ã
                    [0x1F300, 0x1F5FF], // –†–∞–∑–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏ –ø–∏–∫—Ç–æ–≥—Ä–∞–º–º—ã
                    [0x1F600, 0x1F64F], // Emoji
                    [0x1F680, 0x1F6FF], // –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç –∏ –∫–∞—Ä—Ç—ã
                    [0x1F700, 0x1F77F], // –ê–ª—Ö–∏–º–∏—á–µ—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã
                    [0x1F780, 0x1F7FF], // –ì–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ —Ñ–∏–≥—É—Ä—ã
                    [0x1F800, 0x1F8FF], // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–µ–ª–∫–∏-C
                    [0x1F900, 0x1F9FF], // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏ –ø–∏–∫—Ç–æ–≥—Ä–∞–º–º—ã
                    [0x1FA00, 0x1FA6F], // –®–∞—Ö–º–∞—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                    [0x1FA70, 0x1FAFF], // –°–∏–º–≤–æ–ª—ã —É–Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–Ω–æ–π –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω–æ–π —Ç–µ—Ö–Ω–∏–∫–∏
                    [0x1FB00, 0x1FBFF]  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –æ–±–ª–∞—Å—Ç—è—Ö
                ];

                // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—É–ª–∞ —Å–∏–º–≤–æ–ª–∞–º–∏ –∏–∑ –≤—Å–µ—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤
                for (const [start, end] of ranges) {
                    for (let i = start; i <= end && pool.size < 2048; i++) {
                        try {
                            const char = String.fromCodePoint(i);
                            if (char.trim() && char.length === 1) {
                                pool.add(char);
                            }
                        } catch (e) {
                            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                        }
                    }
                }

                return Array.from(pool);
            }

            // –î–µ—Ä–∏–≤–∞—Ü–∏—è –∫–ª—é—á–∞ —Å –ø–æ–º–æ—â—å—é HKDF
            async deriveKey(masterKey, salt, info) {
                const encoder = new TextEncoder();
                
                // –ò–º–ø–æ—Ä—Ç –∫–ª—é—á–∞
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(masterKey),
                    'HKDF',
                    false,
                    ['deriveBits']
                );

                // –î–µ—Ä–∏–≤–∞—Ü–∏—è –∫–ª—é—á–∞
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'HKDF',
                        salt: encoder.encode(salt),
                        info: encoder.encode(info),
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    256
                );

                return new Uint8Array(derivedBits);
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤ –∏–∑ –∫–ª—é—á–∞
            async generateHomophoneTable(masterKey, baseCount = 5) {
                const table = new Map();
                const usedHomophones = new Set();
                
                // –î–µ—Ä–∏–≤–∞—Ü–∏—è –∫–ª—é—á–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü—ã
                const tableKey = await this.deriveKey(masterKey, 'homophone-table-salt', 'table-generation');
                
                // –ü—Å–µ–≤–¥–æ—Å–ª—É—á–∞–π–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                let seed = 0;
                for (let i = 0; i < tableKey.length; i++) {
                    seed = (seed << 8) | tableKey[i];
                }
                
                const rng = this.createKeyDerivedRNG(seed);
                
                // –ê–¥–∞–ø—Ç–∏–≤–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–º–æ—Ñ–æ–Ω–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–º–≤–æ–ª–∞
                for (const char of this.baseAlphabet) {
                    const frequency = this.getCharFrequency(char);
                    const count = this.getAdaptiveCount(baseCount, frequency, rng);
                    
                    const homophones = [];
                    for (let i = 0; i < count; i++) {
                        const homophone = this.selectHomophone(char, usedHomophones, rng);
                        if (homophone) {
                            homophones.push(homophone);
                            usedHomophones.add(homophone);
                        }
                    }
                    
                    table.set(char, homophones);
                }
                
                this.homophoneTable = table;
                return table;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ RNG –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
            createKeyDerivedRNG(seed) {
                let state = seed;
                return {
                    next: () => {
                        state = (state * 1664525 + 1013904223) % 4294967296;
                        return state / 4294967296;
                    },
                    nextInt: (max) => Math.floor(this.next() * max)
                };
            }

            // –ê–¥–∞–ø—Ç–∏–≤–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–º–æ—Ñ–æ–Ω–æ–≤
            getAdaptiveCount(baseCount, frequency, rng) {
                // –ß–∞—Å—Ç—ã–µ —Å–∏–º–≤–æ–ª—ã –ø–æ–ª—É—á–∞—é—Ç –±–æ–ª—å—à–µ –æ–º–æ—Ñ–æ–Ω–æ–≤
                const multiplier = frequency > 0.05 ? 1.5 : frequency > 0.01 ? 1.2 : 1.0;
                return Math.max(2, Math.min(15, Math.floor(baseCount * multiplier + rng.next() * 3)));
            }

            // –í—ã–±–æ—Ä –æ–º–æ—Ñ–æ–Ω–∞ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏
            selectHomophone(char, usedHomophones, rng) {
                let attempts = 0;
                while (attempts < 100) {
                    const index = Math.floor(rng.next() * this.homophonePool.length);
                    const candidate = this.homophonePool[index];
                    
                    if (!usedHomophones.has(candidate) && candidate !== char) {
                        return candidate;
                    }
                    attempts++;
                }
                return null;
            }

            // –ß–∞—Å—Ç–æ—Ç–∞ —Å–∏–º–≤–æ–ª–æ–≤ –≤ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ
            getCharFrequency(char) {
                const freqMap = {
                    '–û': 0.109, '–ï': 0.084, '–ê': 0.080, '–ò': 0.073, '–ù': 0.067,
                    '–¢': 0.063, '–°': 0.055, '–†': 0.053, '–í': 0.049, '–õ': 0.048,
                    '–ö': 0.034, '–ú': 0.033, '–î': 0.031, '–ü': 0.029, '–£': 0.027,
                    '–Ø': 0.020, '–´': 0.019, '–¨': 0.018, '–ì': 0.017, '–ó': 0.017,
                    '–ë': 0.015, '–ß': 0.015, '–ô': 0.013, '–•': 0.011, '–ñ': 0.010,
                    '–®': 0.008, '–Æ': 0.007, '–¶': 0.005, '–©': 0.004, '–≠': 0.003,
                    '–§': 0.002, '–Å': 0.001, '–™': 0.001
                };
                
                const upperChar = char.toUpperCase();
                return freqMap[upperChar] || 0.001;
            }

            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–º–æ—Ñ–æ–Ω–æ–≤ –∫ —Ç–µ–∫—Å—Ç—É
            applyHomophones(text, rng) {
                let result = '';
                for (const char of text) {
                    if (this.homophoneTable.has(char)) {
                        const homophones = this.homophoneTable.get(char);
                        const index = Math.floor(rng.next() * homophones.length);
                        result += homophones[index];
                    } else {
                        result += char;
                    }
                }
                return result;
            }

            // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
            reverseHomophones(text) {
                let result = '';
                const reverseMap = new Map();
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ mapping
                for (const [char, homophones] of this.homophoneTable.entries()) {
                    for (const homophone of homophones) {
                        reverseMap.set(homophone, char);
                    }
                }
                
                for (const char of text) {
                    result += reverseMap.get(char) || char;
                }
                
                return result;
            }

            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å AES-GCM
            async encrypt(plaintext, masterKey) {
                // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤
                await this.generateHomophoneTable(masterKey, parseInt(document.getElementById('homophoneCount').value));
                
                // –î–µ—Ä–∏–≤–∞—Ü–∏—è –∫–ª—é—á–∞ –¥–ª—è AES
                const aesKey = await this.deriveKey(masterKey, 'aes-encryption-salt', 'encryption');
                
                // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è IV
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–º–æ—Ñ–æ–Ω–æ–≤
                const rng = this.createKeyDerivedRNG(Date.now());
                const homophonicText = this.applyHomophones(plaintext, rng);
                
                // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES-GCM
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    aesKey,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt']
                );
                
                const encrypted = await crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128
                    },
                    cryptoKey,
                    new TextEncoder().encode(homophonicText)
                );
                
                // –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ IV + –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);
                
                return btoa(String.fromCharCode(...combined));
            }

            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
            async decrypt(ciphertext, masterKey) {
                try {
                    // –î–µ—Ä–∏–≤–∞—Ü–∏—è –∫–ª—é—á–∞ –¥–ª—è AES
                    const aesKey = await this.deriveKey(masterKey, 'aes-encryption-salt', 'encryption');
                    
                    // –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
                    const binary = atob(ciphertext);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    
                    // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ IV
                    const iv = bytes.slice(0, 12);
                    const encrypted = bytes.slice(12);
                    
                    // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES-GCM
                    const cryptoKey = await crypto.subtle.importKey(
                        'raw',
                        aesKey,
                        { name: 'AES-GCM' },
                        false,
                        ['decrypt']
                    );
                    
                    const decrypted = await crypto.subtle.decrypt(
                        {
                            name: 'AES-GCM',
                            iv: iv,
                            tagLength: 128
                        },
                        cryptoKey,
                        encrypted
                    );
                    
                    const homophonicText = new TextDecoder().decode(decrypted);
                    
                    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
                    await this.generateHomophoneTable(masterKey, parseInt(document.getElementById('homophoneCount').value));
                    
                    // –û–±—Ä–∞—Ç–Ω–æ–µ –æ–º–æ—Ñ–æ–Ω–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                    return this.reverseHomophones(homophonicText);
                    
                } catch (error) {
                    console.error('Decryption error:', error);
                    throw new Error('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: –Ω–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ');
                }
            }

            // –ê–Ω–∞–ª–∏–∑ —ç–Ω—Ç—Ä–æ–ø–∏–∏
            calculateEntropy(text) {
                const freq = {};
                for (const char of text) {
                    freq[char] = (freq[char] || 0) + 1;
                }
                
                let entropy = 0;
                const length = text.length;
                
                for (const count of Object.values(freq)) {
                    const p = count / length;
                    entropy -= p * Math.log2(p);
                }
                
                return entropy;
            }

            // –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑
            frequencyAnalysis(text, limit = 10) {
                const freq = {};
                for (const char of text.replace(/[^\p{L}\p{N}]/gu, '')) {
                    freq[char] = (freq[char] || 0) + 1;
                }
                
                return Object.entries(freq)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, limit)
                    .map(([char, count]) => `${char}: ${count}`);
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        const cipher = new KeyDerivedHomophonicCipher();
        let currentHomophoneTable = new Map();

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –∫–ª—é—á–∞
        async function generateNewKey() {
            const randomBytes = new Uint8Array(32);
            crypto.getRandomValues(randomBytes);
            const key = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('masterKey').value = key;
            await updateHomophoneTable();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤
        async function updateHomophoneTable() {
            const masterKey = document.getElementById('masterKey').value;
            const baseCount = parseInt(document.getElementById('homophoneCount').value);
            
            try {
                currentHomophoneTable = await cipher.generateHomophoneTable(masterKey, baseCount);
                displayHomophoneTablePreview();
            } catch (error) {
                console.error('Error generating homophone table:', error);
            }
        }

        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–µ–≤—å—é —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤
        function displayHomophoneTablePreview() {
            const preview = document.getElementById('homophoneTablePreview');
            preview.innerHTML = '';
            
            let count = 0;
            for (const [char, homophones] of currentHomophoneTable.entries()) {
                if (count++ >= 20) break;
                
                const item = document.createElement('div');
                item.className = 'homophone-item';
                item.innerHTML = `
                    <span class="homophone-char">${char}</span> ‚Üí 
                    ${homophones.slice(0, 3).join(' ')}${homophones.length > 3 ? '...' : ''}
                `;
                preview.appendChild(item);
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
            document.getElementById('tableSize').textContent = currentHomophoneTable.size;
            const uniqueHomophones = new Set();
            for (const homophones of currentHomophoneTable.values()) {
                for (const h of homophones) {
                    uniqueHomophones.add(h);
                }
            }
            document.getElementById('uniqueHomophones').textContent = uniqueHomophones.size;
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        async function encryptText() {
            const inputText = document.getElementById('inputText').value;
            const masterKey = document.getElementById('masterKey').value;
            
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            if (!masterKey) {
                alert('–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á');
                return;
            }
            
            try {
                const encrypted = await cipher.encrypt(inputText, masterKey);
                document.getElementById('outputText').value = encrypted;
                updateMetrics();
            } catch (error) {
                alert('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message);
            }
        }

        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        async function decryptText() {
            const inputText = document.getElementById('inputText').value;
            const masterKey = document.getElementById('masterKey').value;
            
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            if (!masterKey) {
                alert('–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á');
                return;
            }
            
            try {
                const decrypted = await cipher.decrypt(inputText, masterKey);
                document.getElementById('outputText').value = decrypted;
                updateMetrics();
            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
        function updateMetrics() {
            const inputText = document.getElementById('inputText').value;
            const outputText = document.getElementById('outputText').value;
            
            // –ú–µ—Ç—Ä–∏–∫–∏ —Ç–µ–∫—Å—Ç–∞
            document.getElementById('textLength').textContent = inputText.length;
            document.getElementById('textEntropy').textContent = cipher.calculateEntropy(inputText).toFixed(2);
            
            // –ú–µ—Ç—Ä–∏–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            if (outputText) {
                document.getElementById('resultSize').textContent = Math.ceil(outputText.length * 8 / 1024) + ' KB';
                document.getElementById('resultEntropy').textContent = cipher.calculateEntropy(outputText).toFixed(2);
            }
            
            // –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑
            document.getElementById('frequencyOriginal').textContent = 
                cipher.frequencyAnalysis(inputText).join(', ');
            
            if (outputText) {
                document.getElementById('frequencyResult').textContent = 
                    cipher.frequencyAnalysis(outputText).join(', ');
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        window.onload = function() {
            generateNewKey();
            updateMetrics();
            
            // –°–ª—É—à–∞—Ç–µ–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π
            document.getElementById('masterKey').addEventListener('input', updateHomophoneTable);
            document.getElementById('homophoneCount').addEventListener('change', updateHomophoneTable);
            document.getElementById('inputText').addEventListener('input', updateMetrics);
        };
    </script>
</body>
</html>
