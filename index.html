<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum-Inspired Reversible Cipher</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 25px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        input[type="text"], input[type="number"], textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 120px;
            font-family: monospace;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
            margin-right: 10px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.secondary {
            background-color: #95a5a6;
        }
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        .button-group {
            margin-top: 20px;
            margin-bottom: 30px;
        }
        .output-section {
            margin-top: 30px;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            display: none;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            display: block;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            display: block;
        }
        .settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        @media (max-width: 600px) {
            .settings {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Quantum-Inspired Reversible Cipher</h1>
        
        <div class="settings">
            <div class="control-group">
                <label for="controlKey">Control Key (8-64 chars):</label>
                <input type="text" id="controlKey" value="quantumKey">
            </div>
            <div class="control-group">
                <label for="targetKey">Target Key (8-64 chars):</label>
                <input type="text" id="targetKey" value="reversible">
            </div>
            <div class="control-group">
                <label for="rounds">Encryption Rounds (1-10):</label>
                <input type="number" id="rounds" min="1" max="10" value="3">
            </div>
            <div class="control-group">
                <label for="blockSize">Block Size (bits: 32/64/128):</label>
                <input type="number" id="blockSize" min="32" max="128" step="32" value="64">
            </div>
        </div>

        <div class="control-group">
            <label for="inputText">Input Text:</label>
            <textarea id="inputText" placeholder="Enter text to encrypt or ciphertext to decrypt"></textarea>
        </div>

        <div class="button-group">
            <button onclick="encrypt()">Encrypt</button>
            <button onclick="decrypt()">Decrypt</button>
            <button class="secondary" onclick="generateKeys()">Generate Random Keys</button>
            <button class="secondary" onclick="clearAll()">Clear All</button>
        </div>

        <div class="control-group">
            <label for="outputText">Result:</label>
            <textarea id="outputText" readonly></textarea>
        </div>

        <div id="statusMessage" class="status"></div>
    </div>

    <script>
        // Quantum-inspired Toffoli gate (CCNOT) implementation
        class QuantumCipher {
            constructor(controlKey, targetKey, rounds = 3, blockSize = 64) {
                this.controlKey = this.stringToHash(controlKey);
                this.targetKey = this.stringToHash(targetKey);
                this.rounds = rounds;
                this.blockSize = blockSize;
                this.mask = (1n << BigInt(blockSize)) - 1n;
            }

            stringToHash(str) {
                let hash = 0n;
                for (let i = 0; i < str.length; i++) {
                    const charCode = BigInt(str.charCodeAt(i));
                    hash = ((hash << 5n) - hash) + charCode;
                    hash &= this.mask;
                }
                return hash;
            }

            toffoliGate(control1, control2, target) {
                // CCNOT operation: target flips if both controls are 1
                const newTarget = (control1 & control2) ^ target;
                return { control1, control2, target: newTarget };
            }

            mixKeys(block, round) {
                // Nonlinear mixing using Toffoli-inspired operations
                const rotatedControl = (this.controlKey << BigInt(round)) | (this.controlKey >> (BigInt(this.blockSize) - BigInt(round)));
                const rotatedTarget = (this.targetKey << BigInt(round)) | (this.targetKey >> (BigInt(this.blockSize) - BigInt(round)));
                
                let mixed = block ^ rotatedControl;
                const { target } = this.toffoliGate(block, rotatedControl, rotatedTarget);
                mixed = mixed ^ target;
                
                return mixed & this.mask;
            }

            processBlock(block, encrypt = true) {
                let result = block;
                const roundRange = encrypt 
                    ? Array.from({length: this.rounds}, (_, i) => i)
                    : Array.from({length: this.rounds}, (_, i) => this.rounds - 1 - i);

                for (const round of roundRange) {
                    result = this.mixKeys(result, round);
                    // Feistel-like rotation for diffusion
                    result = ((result << 13n) | (result >> (BigInt(this.blockSize) - 13n))) & this.mask;
                }
                return result;
            }

            textToBlocks(text) {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const blocks = [];
                const bytesPerBlock = this.blockSize / 8;
                
                for (let i = 0; i < data.length; i += bytesPerBlock) {
                    let block = 0n;
                    for (let j = 0; j < bytesPerBlock; j++) {
                        if (i + j < data.length) {
                            block = (block << 8n) | BigInt(data[i + j]);
                        } else {
                            block = (block << 8n) | 0n; // Padding with zeros
                        }
                    }
                    blocks.push(block);
                }
                return blocks;
            }

            blocksToText(blocks) {
                const bytes = [];
                const bytesPerBlock = this.blockSize / 8;
                
                for (const block of blocks) {
                    for (let i = bytesPerBlock - 1; i >= 0; i--) {
                        const byte = Number((block >> (BigInt(i) * 8n)) & 255n);
                        if (byte !== 0 || i !== 0) { // Skip trailing zero padding
                            bytes.push(byte);
                        }
                    }
                }
                
                const decoder = new TextDecoder();
                return decoder.decode(new Uint8Array(bytes));
            }

            encrypt(text) {
                const blocks = this.textToBlocks(text);
                const encryptedBlocks = blocks.map(block => this.processBlock(block, true));
                return this.blocksToHex(encryptedBlocks);
            }

            decrypt(hex) {
                const blocks = this.hexToBlocks(hex);
                const decryptedBlocks = blocks.map(block => this.processBlock(block, false));
                return this.blocksToText(decryptedBlocks);
            }

            blocksToHex(blocks) {
                return blocks.map(block => {
                    const hex = block.toString(16);
                    return hex.padStart(this.blockSize / 4, '0');
                }).join('');
            }

            hexToBlocks(hex) {
                const blockSizeHex = this.blockSize / 4;
                const blocks = [];
                for (let i = 0; i < hex.length; i += blockSizeHex) {
                    const chunk = hex.substr(i, blockSizeHex);
                    blocks.push(BigInt('0x' + chunk));
                }
                return blocks;
            }
        }

        // UI Functions
        function showStatus(message, isError = false) {
            const status = document.getElementById('statusMessage');
            status.textContent = message;
            status.className = isError ? 'status error' : 'status success';
            setTimeout(() => {
                status.className = 'status';
                status.textContent = '';
            }, 5000);
        }

        function getCipher() {
            const controlKey = document.getElementById('controlKey').value;
            const targetKey = document.getElementById('targetKey').value;
            const rounds = parseInt(document.getElementById('rounds').value);
            const blockSize = parseInt(document.getElementById('blockSize').value);
            
            if (!controlKey || !targetKey) {
                showStatus('Both control and target keys are required', true);
                return null;
            }
            
            if (controlKey.length < 8 || targetKey.length < 8) {
                showStatus('Keys should be at least 8 characters long', true);
                return null;
            }
            
            return new QuantumCipher(controlKey, targetKey, rounds, blockSize);
        }

        function encrypt() {
            const cipher = getCipher();
            if (!cipher) return;
            
            const input = document.getElementById('inputText').value;
            if (!input) {
                showStatus('Please enter text to encrypt', true);
                return;
            }
            
            try {
                const encrypted = cipher.encrypt(input);
                document.getElementById('outputText').value = encrypted;
                showStatus('Text encrypted successfully!');
            } catch (error) {
                showStatus('Encryption failed: ' + error.message, true);
                console.error(error);
            }
        }

        function decrypt() {
            const cipher = getCipher();
            if (!cipher) return;
            
            const input = document.getElementById('inputText').value;
            if (!input) {
                showStatus('Please enter ciphertext to decrypt', true);
                return;
            }
            
            try {
                const decrypted = cipher.decrypt(input);
                document.getElementById('outputText').value = decrypted;
                showStatus('Text decrypted successfully!');
            } catch (error) {
                showStatus('Decryption failed. Check your keys and input.', true);
                console.error(error);
            }
        }

        function generateKeys() {
            const randomString = (length) => {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            };
            
            document.getElementById('controlKey').value = randomString(16);
            document.getElementById('targetKey').value = randomString(16);
            showStatus('New random keys generated!');
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            showStatus('Cleared all fields');
        }
    </script>
</body>
</html>
