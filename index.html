<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D BitTrifid Cipher Pro</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --success: #27ae60;
            --warning: #f39c12;
            --dark: #1a1a1a;
            --light: #ecf0f1;
            --gray: #7f8c8d;
            --border-radius: 8px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0c2461, #1e3799, #4a69bd);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(26, 26, 26, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 25px;
            background: rgba(44, 62, 80, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            color: var(--secondary);
            text-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
        }

        h2 {
            font-size: 2rem;
            margin: 25px 0;
            color: var(--secondary);
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.5rem;
            margin: 20px 0;
            color: var(--secondary);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        @media (max-width: 1200px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(44, 62, 80, 0.8);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.2);
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--secondary);
            font-size: 1.1rem;
        }

        textarea, input, select {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--secondary);
            border-radius: var(--border-radius);
            background: rgba(26, 26, 26, 0.9);
            color: var(--light);
            font-size: 1rem;
            transition: var(--transition);
        }

        textarea:focus, input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.3);
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        .btn {
            background: linear-gradient(135deg, var(--secondary), #2980b9);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-width: 120px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent), #c0392b);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning), #e67e22);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #229954);
        }

        .cube-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        @media (max-width: 1400px) {
            .cube-container {
                grid-template-columns: 1fr;
            }
        }

        .cube {
            background: rgba(26, 26, 26, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .cube-title {
            text-align: center;
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: var(--secondary);
            font-weight: 600;
        }

        .cube-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            margin: 0 auto;
        }

        .cube-cell {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 2px;
            cursor: pointer;
            transition: var(--transition);
        }

        .cube-cell:hover {
            background: rgba(52, 152, 219, 0.3);
            transform: scale(1.2);
        }

        .cube-cell.byte-high {
            background: rgba(231, 76, 60, 0.6);
            font-weight: bold;
        }

        .cube-cell.byte-medium {
            background: rgba(243, 156, 18, 0.6);
        }

        .visualization-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            align-items: center;
            flex-wrap: wrap;
        }

        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .status-success {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid var(--success);
            color: var(--success);
        }

        .status-error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .status-warning {
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid var(--warning);
            color: var(--warning);
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .process-steps {
            margin-top: 25px;
            padding: 20px;
            background: rgba(26, 26, 26, 0.6);
            border-radius: var(--border-radius);
            border: 1px solid rgba(52, 152, 219, 0.2);
            max-height: 400px;
            overflow-y: auto;
        }

        .step {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 6px;
            font-size: 0.95rem;
            border-left: 4px solid var(--secondary);
        }

        .step-error {
            border-left-color: var(--accent);
            background: rgba(231, 76, 60, 0.1);
        }

        .step-success {
            border-left-color: var(--success);
            background: rgba(39, 174, 96, 0.1);
        }

        .layer-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            align-items: center;
        }

        .performance-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(26, 26, 26, 0.6);
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(52, 152, 219, 0.2);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--secondary);
            margin: 5px 0;
        }

        .stat-label {
            color: var(--gray);
            font-size: 0.9rem;
        }

        footer {
            text-align: center;
            margin-top: 50px;
            padding: 25px;
            color: var(--gray);
            border-top: 1px solid rgba(52, 152, 219, 0.2);
        }

        /* Анимации */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes highlight {
            0% { background-color: rgba(52, 152, 219, 0.1); }
            50% { background-color: rgba(52, 152, 219, 0.4); }
            100% { background-color: rgba(52, 152, 219, 0.1); }
        }

        .highlight {
            animation: highlight 1s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-cubes"></i> 3D BitTrifid Cipher Pro</h1>
            <p>Профессиональная реализация трехкубового 16×16×16 шифрования</p>
        </header>

        <div class="grid">
            <div class="card">
                <h2><i class="fas fa-lock"></i> Шифрование</h2>
                <div class="form-group">
                    <label for="plaintext">Исходный текст:</label>
                    <textarea id="plaintext" placeholder="Введите текст для шифрования..." spellcheck="false"></textarea>
                </div>
                <div class="form-group">
                    <label for="encryptionKey">Ключ шифрования:</label>
                    <input type="password" id="encryptionKey" placeholder="Введите криптографический ключ">
                </div>
                <div class="form-group">
                    <label for="rounds">Количество раундов (8-16):</label>
                    <input type="number" id="rounds" min="8" max="16" value="12">
                </div>
                <div class="action-buttons">
                    <button class="btn" id="encryptBtn">
                        <i class="fas fa-key"></i> Зашифровать
                    </button>
                    <button class="btn btn-danger" id="clearEncrypt">
                        <i class="fas fa-trash"></i> Очистить
                    </button>
                </div>
                <div id="encryptStatus" class="status"></div>
            </div>

            <div class="card">
                <h2><i class="fas fa-lock-open"></i> Дешифрование</h2>
                <div class="form-group">
                    <label for="ciphertext">Зашифрованные данные:</label>
                    <textarea id="ciphertext" placeholder="Введите hex-данные для дешифрования..." spellcheck="false"></textarea>
                </div>
                <div class="form-group">
                    <label for="decryptionKey">Ключ дешифрования:</label>
                    <input type="password" id="decryptionKey" placeholder="Введите криптографический ключ">
                </div>
                <div class="action-buttons">
                    <button class="btn btn-success" id="decryptBtn">
                        <i class="fas fa-unlock"></i> Дешифровать
                    </button>
                    <button class="btn btn-danger" id="clearDecrypt">
                        <i class="fas fa-trash"></i> Очистить
                    </button>
                </div>
                <div id="decryptStatus" class="status"></div>
            </div>
        </div>

        <div class="card">
            <h2><i class="fas fa-project-diagram"></i> Визуализация 3D Кубов</h2>
            
            <div class="visualization-controls">
                <label>Режим отображения:</label>
                <select id="viewMode">
                    <option value="all">Все кубы</option>
                    <option value="cube1">Куб 1</option>
                    <option value="cube2">Куб 2</option>
                    <option value="cube3">Куб 3</option>
                </select>
                <label>Слой Z:</label>
                <input type="range" id="zLayer" min="0" max="15" value="0">
                <span id="currentLayer">0</span>
                <button class="btn btn-warning" id="refreshViz">
                    <i class="fas fa-sync"></i> Обновить
                </button>
            </div>

            <div class="cube-container" id="cubeVisualization">
                <!-- Кубы будут отображены здесь -->
            </div>

            <div class="performance-stats">
                <div class="stat-card">
                    <div class="stat-label">Размер куба</div>
                    <div class="stat-value">16×16×16</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Всего ячеек</div>
                    <div class="stat-value">4096</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Общий объем</div>
                    <div class="stat-value">12КБ</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Время обработки</div>
                    <div class="stat-value" id="processTime">0ms</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2><i class="fas fa-cogs"></i> Процесс шифрования</h2>
            <div class="process-steps" id="processSteps">
                <div class="step">Готов к работе. Введите данные для начала шифрования.</div>
            </div>
        </div>

        <footer>
            <p>3D BitTrifid Cipher Pro © 2024 | Профессиональная криптографическая система</p>
        </footer>
    </div>

    <script>
        class BitTrifid3D {
            constructor() {
                this.cubes = [null, null, null];
                this.cubeSize = 16;
                this.totalCells = this.cubeSize * this.cubeSize * this.cubeSize;
                this.rounds = 12;
                this.initialized = false;
                
                // S-Box для нелинейных преобразований
                this.sBox = this.generateSBox();
                this.invSBox = this.generateInverseSBox();
            }

            generateSBox() {
                const sbox = new Uint8Array(256);
                // Генерация детерминистического S-Box на основе простых чисел
                for (let i = 0; i < 256; i++) {
                    let value = i;
                    // Нелинейное преобразование
                    value = ((value * 31) + 17) % 256;
                    value = value ^ (value >> 4);
                    value = value ^ (value << 5);
                    value = value ^ (value >> 3);
                    sbox[i] = value;
                }
                return sbox;
            }

            generateInverseSBox() {
                const invSbox = new Uint8Array(256);
                for (let i = 0; i < 256; i++) {
                    invSbox[this.sBox[i]] = i;
                }
                return invSbox;
            }

            async initializeCubes(key) {
                this.addProcessStep("Инициализация кубов...");
                
                this.cubes = [
                    new Array(this.cubeSize),
                    new Array(this.cubeSize), 
                    new Array(this.cubeSize)
                ];

                // Инициализация кубов на основе ключа
                const keyBytes = new TextEncoder().encode(key);
                let keyIndex = 0;

                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    this.cubes[cubeIdx] = new Array(this.cubeSize);
                    
                    for (let x = 0; x < this.cubeSize; x++) {
                        this.cubes[cubeIdx][x] = new Array(this.cubeSize);
                        
                        for (let y = 0; y < this.cubeSize; y++) {
                            this.cubes[cubeIdx][x][y] = new Array(this.cubeSize);
                            
                            for (let z = 0; z < this.cubeSize; z++) {
                                const keyByte = keyBytes[keyIndex % keyBytes.length];
                                const positionHash = this.hashPosition(x, y, z, cubeIdx);
                                this.cubes[cubeIdx][x][y][z] = (keyByte + positionHash) % 256;
                                keyIndex++;
                            }
                        }
                    }
                }

                this.initialized = true;
                this.addProcessStep("Кубы успешно инициализированы", "success");
            }

            hashPosition(x, y, z, cubeIdx) {
                // Простая хеш-функция для позиции
                return (x * 7919 + y * 65537 + z * 257 + cubeIdx * 104729) % 256;
            }

            async encrypt(data, key, rounds = 12) {
                const startTime = performance.now();
                this.addProcessStep("Начало шифрования...");
                
                await this.initializeCubes(key);
                this.rounds = rounds;

                // Конвертация данных в байты
                const encoder = new TextEncoder();
                const dataBytes = encoder.encode(data);
                this.addProcessStep(`Данные конвертированы в ${dataBytes.length} байт`);

                // Размещение данных в кубах
                this.distributeData(dataBytes);
                this.addProcessStep("Данные распределены по кубам");

                // Многопроходное шифрование
                for (let round = 0; round < this.rounds; round++) {
                    this.addProcessStep(`Раунд ${round + 1}/${this.rounds}`);
                    this.processRound(round);
                }

                // Извлечение зашифрованных данных
                const encryptedData = this.extractData();
                this.addProcessStep("Данные извлечены из кубов");

                const hexResult = Array.from(encryptedData).map(b => 
                    b.toString(16).padStart(2, '0')).join('');

                const endTime = performance.now();
                this.addProcessStep(`Шифрование завершено за ${(endTime - startTime).toFixed(2)}ms`, "success");

                return hexResult;
            }

            distributeData(dataBytes) {
                let dataIndex = 0;
                
                for (let x = 0; x < this.cubeSize; x++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let z = 0; z < this.cubeSize; z++) {
                            for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                                if (dataIndex < dataBytes.length) {
                                    this.cubes[cubeIdx][x][y][z] = dataBytes[dataIndex++];
                                } else {
                                    // Дополнение нулями
                                    this.cubes[cubeIdx][x][y][z] = 0;
                                }
                            }
                        }
                    }
                }
            }

            processRound(round) {
                // 1. Нелинейная замена (S-Box)
                this.applySBox();
                this.addProcessStep("Применен S-Box");

                // 2. Перемешивание между кубами
                this.mixCubes();
                this.addProcessStep("Выполнено перемешивание кубов");

                // 3. Вращение слоев
                this.rotateLayers(round);
                this.addProcessStep("Выполнено вращение слоев");

                // 4. Диффузия внутри кубов
                this.diffuseCubes();
                this.addProcessStep("Выполнена диффузия");
            }

            applySBox() {
                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    for (let x = 0; x < this.cubeSize; x++) {
                        for (let y = 0; y < this.cubeSize; y++) {
                            for (let z = 0; z < this.cubeSize; z++) {
                                this.cubes[cubeIdx][x][y][z] = this.sBox[this.cubes[cubeIdx][x][y][z]];
                            }
                        }
                    }
                }
            }

            mixCubes() {
                const tempCube = new Array(this.cubeSize);
                
                for (let x = 0; x < this.cubeSize; x++) {
                    tempCube[x] = new Array(this.cubeSize);
                    for (let y = 0; y < this.cubeSize; y++) {
                        tempCube[x][y] = new Array(this.cubeSize);
                    }
                }

                // Перемешивание между кубом 1 и 2
                for (let x = 0; x < this.cubeSize; x++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let z = 0; z < this.cubeSize; z++) {
                            tempCube[x][y][z] = this.cubes[0][x][y][z];
                            this.cubes[0][x][y][z] = this.cubes[1][y][z][x];
                            this.cubes[1][y][z][x] = tempCube[x][y][z];
                        }
                    }
                }

                // Перемешивание между кубом 2 и 3
                for (let x = 0; x < this.cubeSize; x++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let z = 0; z < this.cubeSize; z++) {
                            tempCube[x][y][z] = this.cubes[1][x][y][z];
                            this.cubes[1][x][y][z] = this.cubes[2][z][x][y];
                            this.cubes[2][z][x][y] = tempCube[x][y][z];
                        }
                    }
                }
            }

            rotateLayers(round) {
                const rotationAmount = (round + 1) % this.cubeSize;
                
                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    for (let z = 0; z < this.cubeSize; z++) {
                        // Вращение по X
                        for (let y = 0; y < this.cubeSize; y++) {
                            const temp = [...this.cubes[cubeIdx][0][y][z]];
                            for (let x = 0; x < this.cubeSize; x++) {
                                this.cubes[cubeIdx][x][y][z] = 
                                    this.cubes[cubeIdx][(x + rotationAmount) % this.cubeSize][y][z];
                            }
                            for (let x = 0; x < rotationAmount; x++) {
                                this.cubes[cubeIdx][this.cubeSize - rotationAmount + x][y][z] = temp[x];
                            }
                        }
                    }
                }
            }

            diffuseCubes() {
                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    for (let x = 0; x < this.cubeSize; x++) {
                        for (let y = 0; y < this.cubeSize; y++) {
                            for (let z = 0; z < this.cubeSize; z++) {
                                // Простая диффузия с соседями
                                let sum = 0;
                                let count = 0;
                                
                                for (let dx = -1; dx <= 1; dx++) {
                                    for (let dy = -1; dy <= 1; dy++) {
                                        for (let dz = -1; dz <= 1; dz++) {
                                            const nx = (x + dx + this.cubeSize) % this.cubeSize;
                                            const ny = (y + dy + this.cubeSize) % this.cubeSize;
                                            const nz = (z + dz + this.cubeSize) % this.cubeSize;
                                            
                                            sum += this.cubes[cubeIdx][nx][ny][nz];
                                            count++;
                                        }
                                    }
                                }
                                
                                this.cubes[cubeIdx][x][y][z] = (this.cubes[cubeIdx][x][y][z] + Math.floor(sum / count)) % 256;
                            }
                        }
                    }
                }
            }

            extractData() {
                const result = [];
                
                for (let x = 0; x < this.cubeSize; x++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let z = 0; z < this.cubeSize; z++) {
                            for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                                result.push(this.cubes[cubeIdx][x][y][z]);
                            }
                        }
                    }
                }
                
                return new Uint8Array(result);
            }

            async decrypt(hexData, key, rounds = 12) {
                const startTime = performance.now();
                this.addProcessStep("Начало дешифрования...");
                
                await this.initializeCubes(key);
                this.rounds = rounds;

                // Конвертация hex в байты
                const bytes = new Uint8Array(hexData.match(/.{1,2}/g).map(b => parseInt(b, 16)));
                this.addProcessStep(`Данные конвертированы из hex в ${bytes.length} байт`);

                // Размещение данных в кубах
                this.distributeData(bytes);
                this.addProcessStep("Данные распределены по кубам");

                // Обратное многопроходное дешифрование
                for (let round = this.rounds - 1; round >= 0; round--) {
                    this.addProcessStep(`Обратный раунд ${this.rounds - round}/${this.rounds}`);
                    this.reverseRound(round);
                }

                // Извлечение данных
                const decryptedData = this.extractData();
                this.addProcessStep("Данные извлечены из кубов");

                // Удаление padding и конвертация в текст
                const decoder = new TextDecoder();
                let text = decoder.decode(decryptedData).replace(/\0+$/, '');

                const endTime = performance.now();
                this.addProcessStep(`Дешифрование завершено за ${(endTime - startTime).toFixed(2)}ms`, "success");

                return text;
            }

            reverseRound(round) {
                // Обратные операции в обратном порядке
                this.reverseDiffuseCubes();
                this.addProcessStep("Отменена диффузия");

                this.reverseRotateLayers(round);
                this.addProcessStep("Отменено вращение слоев");

                this.reverseMixCubes();
                this.addProcessStep("Отменено перемешивание кубов");

                this.applyInverseSBox();
                this.addProcessStep("Применен обратный S-Box");
            }

            reverseDiffuseCubes() {
                // Упрощенная обратная диффузия
                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    for (let x = 0; x < this.cubeSize; x++) {
                        for (let y = 0; y < this.cubeSize; y++) {
                            for (let z = 0; z < this.cubeSize; z++) {
                                // Приблизительная обратная операция
                                let sum = 0;
                                let count = 0;
                                
                                for (let dx = -1; dx <= 1; dx++) {
                                    for (let dy = -1; dy <= 1; dy++) {
                                        for (let dz = -1; dz <= 1; dz++) {
                                            const nx = (x + dx + this.cubeSize) % this.cubeSize;
                                            const ny = (y + dy + this.cubeSize) % this.cubeSize;
                                            const nz = (z + dz + this.cubeSize) % this.cubeSize;
                                            
                                            sum += this.cubes[cubeIdx][nx][ny][nz];
                                            count++;
                                        }
                                    }
                                }
                                
                                const avg = Math.floor(sum / count);
                                this.cubes[cubeIdx][x][y][z] = (this.cubes[cubeIdx][x][y][z] - avg + 256) % 256;
                            }
                        }
                    }
                }
            }

            reverseRotateLayers(round) {
                const rotationAmount = (round + 1) % this.cubeSize;
                const reverseAmount = (this.cubeSize - rotationAmount) % this.cubeSize;
                
                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    for (let z = 0; z < this.cubeSize; z++) {
                        // Обратное вращение по X
                        for (let y = 0; y < this.cubeSize; y++) {
                            const temp = [...this.cubes[cubeIdx][0][y][z]];
                            for (let x = 0; x < this.cubeSize; x++) {
                                this.cubes[cubeIdx][x][y][z] = 
                                    this.cubes[cubeIdx][(x + reverseAmount) % this.cubeSize][y][z];
                            }
                            for (let x = 0; x < reverseAmount; x++) {
                                this.cubes[cubeIdx][this.cubeSize - reverseAmount + x][y][z] = temp[x];
                            }
                        }
                    }
                }
            }

            reverseMixCubes() {
                const tempCube = new Array(this.cubeSize);
                
                for (let x = 0; x < this.cubeSize; x++) {
                    tempCube[x] = new Array(this.cubeSize);
                    for (let y = 0; y < this.cubeSize; y++) {
                        tempCube[x][y] = new Array(this.cubeSize);
                    }
                }

                // Обратное перемешивание между кубом 2 и 3
                for (let x = 0; x < this.cubeSize; x++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let z = 0; z < this.cubeSize; z++) {
                            tempCube[x][y][z] = this.cubes[2][z][x][y];
                            this.cubes[2][z][x][y] = this.cubes[1][x][y][z];
                            this.cubes[1][x][y][z] = tempCube[x][y][z];
                        }
                    }
                }

                // Обратное перемешивание между кубом 1 и 2
                for (let x = 0; x < this.cubeSize; x++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let z = 0; z < this.cubeSize; z++) {
                            tempCube[x][y][z] = this.cubes[1][y][z][x];
                            this.cubes[1][y][z][x] = this.cubes[0][x][y][z];
                            this.cubes[0][x][y][z] = tempCube[x][y][z];
                        }
                    }
                }
            }

            applyInverseSBox() {
                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    for (let x = 0; x < this.cubeSize; x++) {
                        for (let y = 0; y < this.cubeSize; y++) {
                            for (let z = 0; z < this.cubeSize; z++) {
                                this.cubes[cubeIdx][x][y][z] = this.invSBox[this.cubes[cubeIdx][x][y][z]];
                            }
                        }
                    }
                }
            }

            addProcessStep(message, type = "info") {
                const stepDiv = document.createElement('div');
                stepDiv.className = `step ${type === 'error' ? 'step-error' : type === 'success' ? 'step-success' : ''}`;
                stepDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                document.getElementById('processSteps').appendChild(stepDiv);
                document.getElementById('processSteps').scrollTop = document.getElementById('processSteps').scrollHeight;
            }

            visualizeCube(layerZ = 0) {
                const container = document.getElementById('cubeVisualization');
                container.innerHTML = '';

                if (!this.initialized) {
                    container.innerHTML = '<div class="status status-warning">Кубы не инициализированы</div>';
                    return;
                }

                for (let cubeIdx = 0; cubeIdx < 3; cubeIdx++) {
                    const cubeDiv = document.createElement('div');
                    cubeDiv.className = 'cube';
                    
                    const title = document.createElement('div');
                    title.className = 'cube-title';
                    title.textContent = `Куб ${cubeIdx + 1} (Z=${layerZ})`;
                    cubeDiv.appendChild(title);

                    const grid = document.createElement('div');
                    grid.className = 'cube-grid';

                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let x = 0; x < this.cubeSize; x++) {
                            const cell = document.createElement('div');
                            cell.className = 'cube-cell';
                            const value = this.cubes[cubeIdx][x][y][layerZ];
                            cell.textContent = value.toString(16).padStart(2, '0');
                            cell.title = `X:${x}, Y:${y}, Z:${layerZ}, Value:${value}`;
                            
                            if (value > 200) {
                                cell.classList.add('byte-high');
                            } else if (value > 100) {
                                cell.classList.add('byte-medium');
                            }
                            
                            grid.appendChild(cell);
                        }
                    }

                    cubeDiv.appendChild(grid);
                    container.appendChild(cubeDiv);
                }
            }
        }

        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', function() {
            const cipher = new BitTrifid3D();
            const processSteps = document.getElementById('processSteps');
            
            // Элементы управления
            const encryptBtn = document.getElementById('encryptBtn');
            const decryptBtn = document.getElementById('decryptBtn');
            const clearEncryptBtn = document.getElementById('clearEncrypt');
            const clearDecryptBtn = document.getElementById('clearDecrypt');
            const refreshVizBtn = document.getElementById('refreshViz');
            const zLayerSlider = document.getElementById('zLayer');
            const currentLayerSpan = document.getElementById('currentLayer');

            // Обновление визуализации
            function updateVisualization() {
                const layerZ = parseInt(zLayerSlider.value);
                currentLayerSpan.textContent = layerZ;
                cipher.visualizeCube(layerZ);
            }

            // Шифрование
            encryptBtn.addEventListener('click', async function() {
                const plaintext = document.getElementById('plaintext').value;
                const key = document.getElementById('encryptionKey').value;
                const rounds = parseInt(document.getElementById('rounds').value);

                if (!plaintext) {
                    document.getElementById('encryptStatus').textContent = 'Введите текст для шифрования';
                    document.getElementById('encryptStatus').className = 'status status-error';
                    return;
                }

                if (!key) {
                    document.getElementById('encryptStatus').textContent = 'Введите ключ шифрования';
                    document.getElementById('encryptStatus').className = 'status status-error';
                    return;
                }

                try {
                    document.getElementById('encryptStatus').textContent = 'Шифрование...';
                    document.getElementById('encryptStatus').className = 'status status-warning';
                    
                    const encrypted = await cipher.encrypt(plaintext, key, rounds);
                    document.getElementById('ciphertext').value = encrypted;
                    
                    document.getElementById('encryptStatus').textContent = 'Шифрование успешно завершено';
                    document.getElementById('encryptStatus').className = 'status status-success';
                    
                    updateVisualization();
                } catch (error) {
                    document.getElementById('encryptStatus').textContent = 'Ошибка шифрования: ' + error.message;
                    document.getElementById('encryptStatus').className = 'status status-error';
                    cipher.addProcessStep('Ошибка: ' + error.message, 'error');
                }
            });

            // Дешифрование
            decryptBtn.addEventListener('click', async function() {
                const ciphertext = document.getElementById('ciphertext').value;
                const key = document.getElementById('decryptionKey').value;

                if (!ciphertext) {
                    document.getElementById('decryptStatus').textContent = 'Введите данные для дешифрования';
                    document.getElementById('decryptStatus').className = 'status status-error';
                    return;
                }

                if (!key) {
                    document.getElementById('decryptStatus').textContent = 'Введите ключ дешифрования';
                    document.getElementById('decryptStatus').className = 'status status-error';
                    return;
                }

                try {
                    document.getElementById('decryptStatus').textContent = 'Дешифрование...';
                    document.getElementById('decryptStatus').className = 'status status-warning';
                    
                    const decrypted = await cipher.decrypt(ciphertext, key);
                    document.getElementById('plaintext').value = decrypted;
                    
                    document.getElementById('decryptStatus').textContent = 'Дешифрование успешно завершено';
                    document.getElementById('decryptStatus').className = 'status status-success';
                    
                    updateVisualization();
                } catch (error) {
                    document.getElementById('decryptStatus').textContent = 'Ошибка дешифрования: ' + error.message;
                    document.getElementById('decryptStatus').className = 'status status-error';
                    cipher.addProcessStep('Ошибка: ' + error.message, 'error');
                }
            });

            // Очистка
            clearEncryptBtn.addEventListener('click', function() {
                document.getElementById('plaintext').value = '';
                document.getElementById('encryptionKey').value = '';
                document.getElementById('encryptStatus').textContent = '';
            });

            clearDecryptBtn.addEventListener('click', function() {
                document.getElementById('ciphertext').value = '';
                document.getElementById('decryptionKey').value = '';
                document.getElementById('decryptStatus').textContent = '';
            });

            // Обновление визуализации
            refreshVizBtn.addEventListener('click', updateVisualization);
            zLayerSlider.addEventListener('input', function() {
                currentLayerSpan.textContent = this.value;
                updateVisualization();
            });

            // Инициализация
            cipher.addProcessStep("Система инициализирована. Готов к работе.");
            updateVisualization();
        });
    </script>
</body>
</html>
