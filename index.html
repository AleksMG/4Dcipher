<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D BitTrifid Cipher - 16×16 Боксы</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #3a56d4;
            --primary-dark: #2c429c;
            --secondary: #4cc9f0;
            --accent: #f72585;
            --light: #f8f9fa;
            --dark: #121212;
            --gray: #6c757d;
            --light-gray: #e9ecef;
            --success: #4cc9f0;
            --error: #f72585;
            --warning: #f8961e;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --card-bg: rgba(255, 255, 255, 0.95);
            --input-bg: rgba(255, 255, 255, 0.9);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--secondary);
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.7);
        }

        h2 {
            font-size: 1.8rem;
            margin: 20px 0;
            color: var(--secondary);
        }

        h3 {
            font-size: 1.4rem;
            margin: 15px 0;
            color: var(--secondary);
        }

        .description {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }

        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--secondary);
        }

        textarea, input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--primary);
            border-radius: 6px;
            background: rgba(10, 10, 20, 0.8);
            color: var(--light);
            font-size: 16px;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn i {
            font-size: 18px;
        }

        .visualization {
            margin-top: 30px;
            overflow: auto;
        }

        .box-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            margin: 15px 0;
        }

        .bit-cell {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            background: rgba(76, 201, 240, 0.2);
            border: 1px solid rgba(76, 201, 240, 0.3);
            transition: all 0.2s;
        }

        .bit-cell:hover {
            background: rgba(76, 201, 240, 0.5);
            transform: scale(1.2);
        }

        .bit-1 {
            background: rgba(76, 201, 240, 0.8);
            font-weight: bold;
        }

        .layer-controls {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            align-items: center;
        }

        .algorithm-info {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
        }

        .algorithm-info ul {
            margin: 15px 0;
            padding-left: 20px;
        }

        .algorithm-info li {
            margin-bottom: 10px;
        }

        .highlight {
            color: var(--secondary);
            font-weight: bold;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            font-size: 0.9rem;
            color: var(--gray);
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .bit-operation {
            background: rgba(247, 37, 133, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .operation-title {
            color: var(--accent);
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }

        .success {
            background: rgba(76, 201, 240, 0.2);
            color: var(--success);
        }

        .error {
            background: rgba(247, 37, 133, 0.2);
            color: var(--error);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-cube"></i> 3D BitTrifid Cipher</h1>
            <p class="description">Шифрование на основе битовых боксов 16×16 с использованием принципов AES</p>
        </header>

        <div class="grid">
            <div class="card">
                <h2><i class="fas fa-lock"></i> Шифрование</h2>
                <div class="form-group">
                    <label for="inputData">Входные данные:</label>
                    <textarea id="inputData" placeholder="Введите текст для шифрования..."></textarea>
                </div>
                <div class="form-group">
                    <label for="encryptionKey">Ключ шифрования (256 бит):</label>
                    <input type="text" id="encryptionKey" placeholder="Введите ключ...">
                </div>
                <button class="btn" id="encryptBtn"><i class="fas fa-key"></i> Зашифровать</button>
                <div id="encryptStatus" class="status"></div>
            </div>

            <div class="card">
                <h2><i class="fas fa-lock-open"></i> Дешифрование</h2>
                <div class="form-group">
                    <label for="encryptedData">Зашифрованные данные:</label>
                    <textarea id="encryptedData" placeholder="Введите данные для дешифрования..."></textarea>
                </div>
                <div class="form-group">
                    <label for="decryptionKey">Ключ дешифрования (256 бит):</label>
                    <input type="text" id="decryptionKey" placeholder="Введите ключ...">
                </div>
                <button class="btn" id="decryptBtn"><i class="fas fa-unlock"></i> Дешифровать</button>
                <div id="decryptStatus" class="status"></div>
            </div>
        </div>

        <div class="card">
            <h2><i class="fas fa-project-diagram"></i> Визуализация битовых боксов 16×16</h2>
            <p>Каждый бокс представляет собой матрицу 16×16 битов (256 бит), аналогично структуре данных в AES.</p>
            
            <div class="layer-controls">
                <label>Слой бокса: </label>
                <select id="layerSelector">
                    <option value="0">Слой 1</option>
                    <option value="1">Слой 2</option>
                    <option value="2">Слой 3</option>
                    <option value="3">Слой 4</option>
                </select>
                <button class="btn" id="visualizeBtn"><i class="fas fa-eye"></i> Визуализировать</button>
            </div>

            <div class="visualization">
                <h3>Битовый бокс 16×16 (слой <span id="currentLayer">1</span>)</h3>
                <div class="box-grid" id="bitBox">
                    <!-- Битовая сетка будет сгенерирована JavaScript -->
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn" id="subBytesBtn"><i class="fas fa-sync"></i> SubBytes преобразование</button>
                <button class="btn" id="shiftRowsBtn"><i class="fas fa-exchange-alt"></i> ShiftRows преобразование</button>
                <button class="btn" id="mixColumnsBtn"><i class="fas fa-th"></i> MixColumns преобразование</button>
                <button class="btn" id="addRoundKeyBtn"><i class="fas fa-plus-circle"></i> AddRoundKey</button>
            </div>
        </div>

        <div class="algorithm-info">
            <h2><i class="fas fa-info-circle"></i> Принципы работы алгоритма</h2>
            <p>Данная реализация использует битовые боксы 16×16, аналогичные по структуре используемым в AES:</p>
            
            <ul>
                <li>Каждый <span class="highlight">битовый бокс 16×16</span> содержит 256 бит информации</li>
                <li>Данные обрабатываются <span class="highlight">послойно</span> с применением различных преобразований</li>
                <li>Используются преобразования, аналогичные AES: <span class="highlight">SubBytes, ShiftRows, MixColumns, AddRoundKey</span></li>
                <li>Ключ шифрования составляет <span class="highlight">256 бит</span> (32 байта)</li>
                <li>Алгоритм работает в нескольких <span class="highlight">раундах</span> для повышения безопасности</li>
            </ul>

            <div class="bit-operation">
                <div class="operation-title">SubBytes преобразование:</div>
                <p>Каждый байт в боксе заменяется на соответствующий ему байт из S-Box таблицы, обеспечивая нелинейность преобразований.</p>
            </div>

            <div class="bit-operation">
                <div class="operation-title">ShiftRows преобразование:</div>
                <p>Строки бокса сдвигаются циклически на определенное количество позиций, обеспечивая диффузию битов.</p>
            </div>

            <div class="bit-operation">
                <div class="operation-title">MixColumns преобразование:</div>
                <p>Преобразование, которое перемешивает байты в каждом столбце бокса,进一步增强 диффузию.</p>
            </div>
        </div>

        <footer>
            <p>3D BitTrifid Cipher &copy; 2023 | Разработано на основе принципов AES с битовыми боксами 16×16</p>
        </footer>
    </div>

    <script>
        class BitTrifidCipher {
            constructor() {
                this.bitBoxes = [];
                this.currentBox = null;
                this.rounds = 10;
                this.sBox = this.generateSBox();
                this.invSBox = this.generateInvSBox();
            }

            // Генерация S-Box для SubBytes преобразования
            generateSBox() {
                // Это упрощенная версия S-Box, в реальном AES она генерируется сложнее
                const sBox = new Uint8Array(256);
                for (let i = 0; i < 256; i++) {
                    sBox[i] = this.subByte(i);
                }
                return sBox;
            }

            generateInvSBox() {
                const invSBox = new Uint8Array(256);
                for (let i = 0; i < 256; i++) {
                    invSBox[this.sBox[i]] = i;
                }
                return invSBox;
            }

            subByte(byte) {
                // Упрощенная версия преобразования SubByte
                let transformed = byte;
                for (let i = 0; i < 4; i++) {
                    transformed = ((transformed << 1) | (transformed >> 7)) & 0xFF;
                    transformed ^= 0x1B;
                }
                return transformed ^ 0x63;
            }

            // Инициализация битового бокса 16x16 из данных
            initializeBox(data) {
                const box = new Uint8Array(256);
                const dataBytes = new TextEncoder().encode(data);
                
                for (let i = 0; i < 256; i++) {
                    box[i] = dataBytes[i % dataBytes.length] ^ i;
                }
                
                return box;
            }

            // Преобразование SubBytes
            subBytes(box) {
                const newBox = new Uint8Array(256);
                for (let i = 0; i < 256; i++) {
                    newBox[i] = this.sBox[box[i]];
                }
                return newBox;
            }

            // Преобразование ShiftRows
            shiftRows(box) {
                const newBox = new Uint8Array(256);
                
                for (let row = 0; row < 16; row++) {
                    for (let col = 0; col < 16; col++) {
                        const newCol = (col + row) % 16;
                        newBox[row * 16 + newCol] = box[row * 16 + col];
                    }
                }
                
                return newBox;
            }

            // Преобразование MixColumns
            mixColumns(box) {
                const newBox = new Uint8Array(256);
                
                for (let col = 0; col < 16; col++) {
                    for (let row = 0; row < 16; row += 4) {
                        if (row + 3 < 16) {
                            const a0 = box[row * 16 + col];
                            const a1 = box[(row + 1) * 16 + col];
                            const a2 = box[(row + 2) * 16 + col];
                            const a3 = box[(row + 3) * 16 + col];
                            
                            newBox[row * 16 + col] = a1 ^ a2 ^ a3;
                            newBox[(row + 1) * 16 + col] = a0 ^ a2 ^ a3;
                            newBox[(row + 2) * 16 + col] = a0 ^ a1 ^ a3;
                            newBox[(row + 3) * 16 + col] = a0 ^ a1 ^ a2;
                        }
                    }
                }
                
                return newBox;
            }

            // Генерация раундовых ключей
            generateRoundKeys(key) {
                const keyBytes = new TextEncoder().encode(key.padEnd(32, ' ').slice(0, 32));
                const roundKeys = [keyBytes];
                
                for (let i = 1; i <= this.rounds; i++) {
                    const prevKey = roundKeys[i - 1];
                    const newKey = new Uint8Array(32);
                    
                    for (let j = 0; j < 32; j++) {
                        newKey[j] = prevKey[j] ^ i ^ j;
                    }
                    
                    roundKeys.push(newKey);
                }
                
                return roundKeys;
            }

            // Преобразование AddRoundKey
            addRoundKey(box, roundKey) {
                const newBox = new Uint8Array(256);
                
                for (let i = 0; i < 256; i++) {
                    newBox[i] = box[i] ^ roundKey[i % 32];
                }
                
                return newBox;
            }

            // Основная функция шифрования
            encrypt(data, key) {
                try {
                    // Инициализация бокса
                    let box = this.initializeBox(data);
                    
                    // Генерация раундовых ключей
                    const roundKeys = this.generateRoundKeys(key);
                    
                    // Применение раундовых преобразований
                    for (let round = 0; round < this.rounds; round++) {
                        box = this.subBytes(box);
                        box = this.shiftRows(box);
                        if (round < this.rounds - 1) {
                            box = this.mixColumns(box);
                        }
                        box = this.addRoundKey(box, roundKeys[round]);
                    }
                    
                    // Преобразование бокса в hex-строку
                    return Array.from(box).map(b => b.toString(16).padStart(2, '0')).join('');
                } catch (error) {
                    console.error('Encryption error:', error);
                    throw new Error('Ошибка шифрования: ' + error.message);
                }
            }

            // Основная функция дешифрования
            decrypt(hexData, key) {
                try {
                    // Преобразование hex-строки в бокс
                    const box = new Uint8Array(hexData.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    
                    // Генерация раундовых ключей
                    const roundKeys = this.generateRoundKeys(key);
                    
                    // Обратные преобразования в обратном порядке
                    for (let round = this.rounds - 1; round >= 0; round--) {
                        box = this.addRoundKey(box, roundKeys[round]);
                        if (round < this.rounds - 1) {
                            // Обратное MixColumns (в этой упрощенной версии оно совпадает с прямым)
                            box = this.mixColumns(box);
                        }
                        box = this.shiftRows(box); // Обратный ShiftRows
                        box = this.subBytes(box);  // Обратный SubBytes (в реальном AES используется InvSubBytes)
                    }
                    
                    // Преобразование бокса в строку
                    return new TextDecoder().decode(box).replace(/\0+$/, '');
                } catch (error) {
                    console.error('Decryption error:', error);
                    throw new Error('Ошибка дешифрования: ' + error.message);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const cipher = new BitTrifidCipher();
            const bitBox = document.getElementById('bitBox');
            const layerSelector = document.getElementById('layerSelector');
            const currentLayer = document.getElementById('currentLayer');
            const visualizeBtn = document.getElementById('visualizeBtn');
            const encryptBtn = document.getElementById('encryptBtn');
            const decryptBtn = document.getElementById('decryptBtn');
            const encryptStatus = document.getElementById('encryptStatus');
            const decryptStatus = document.getElementById('decryptStatus');
            
            // Генерация визуализации битового бокса
            function visualizeBitBox(boxData) {
                bitBox.innerHTML = '';
                if (!boxData || boxData.length !== 256) {
                    for (let i = 0; i < 256; i++) {
                        const bitCell = document.createElement('div');
                        bitCell.className = 'bit-cell';
                        bitCell.textContent = '0';
                        bitBox.appendChild(bitCell);
                    }
                    return;
                }
                
                for (let i = 0; i < 256; i++) {
                    const bitCell = document.createElement('div');
                    bitCell.className = 'bit-cell';
                    const byte = boxData[i];
                    
                    // Отображаем только один бит для простоты визуализации
                    const bit = (byte >> (i % 8)) & 1;
                    bitCell.textContent = bit;
                    
                    if (bit === 1) {
                        bitCell.classList.add('bit-1');
                    }
                    
                    bitBox.appendChild(bitCell);
                }
            }
            
            // Обновление слоя
            layerSelector.addEventListener('change', function() {
                currentLayer.textContent = parseInt(this.value) + 1;
                if (cipher.currentBox) {
                    visualizeBitBox(cipher.currentBox);
                }
            });
            
            // Визуализация
            visualizeBtn.addEventListener('click', function() {
                if (cipher.currentBox) {
                    visualizeBitBox(cipher.currentBox);
                } else {
                    visualizeBitBox();
                    encryptStatus.textContent = 'Сначала выполните шифрование';
                    encryptStatus.className = 'status error';
                }
            });
            
            // Шифрование
            encryptBtn.addEventListener('click', function() {
                const inputData = document.getElementById('inputData').value;
                const key = document.getElementById('encryptionKey').value;
                
                if (!inputData) {
                    encryptStatus.textContent = 'Введите данные для шифрования';
                    encryptStatus.className = 'status error';
                    return;
                }
                
                if (!key || key.length < 8) {
                    encryptStatus.textContent = 'Ключ должен быть не менее 8 символов';
                    encryptStatus.className = 'status error';
                    return;
                }
                
                try {
                    const encrypted = cipher.encrypt(inputData, key);
                    document.getElementById('encryptedData').value = encrypted;
                    
                    // Инициализируем бокс для визуализации
                    cipher.currentBox = cipher.initializeBox(inputData);
                    visualizeBitBox(cipher.currentBox);
                    
                    encryptStatus.textContent = 'Данные успешно зашифрованы';
                    encryptStatus.className = 'status success';
                } catch (error) {
                    encryptStatus.textContent = error.message;
                    encryptStatus.className = 'status error';
                }
            });
            
            // Дешифрование
            decryptBtn.addEventListener('click', function() {
                const encryptedData = document.getElementById('encryptedData').value;
                const key = document.getElementById('decryptionKey').value;
                
                if (!encryptedData) {
                    decryptStatus.textContent = 'Введите данные для дешифрования';
                    decryptStatus.className = 'status error';
                    return;
                }
                
                if (!key || key.length < 8) {
                    decryptStatus.textContent = 'Ключ должен быть не менее 8 символов';
                    decryptStatus.className = 'status error';
                    return;
                }
                
                try {
                    const decrypted = cipher.decrypt(encryptedData, key);
                    document.getElementById('inputData').value = decrypted;
                    
                    decryptStatus.textContent = 'Данные успешно дешифрованы';
                    decryptStatus.className = 'status success';
                } catch (error) {
                    decryptStatus.textContent = error.message;
                    decryptStatus.className = 'status error';
                }
            });
            
            // Обработчики для преобразований
            document.getElementById('subBytesBtn').addEventListener('click', function() {
                if (cipher.currentBox) {
                    cipher.currentBox = cipher.subBytes(cipher.currentBox);
                    visualizeBitBox(cipher.currentBox);
                }
            });
            
            document.getElementById('shiftRowsBtn').addEventListener('click', function() {
                if (cipher.currentBox) {
                    cipher.currentBox = cipher.shiftRows(cipher.currentBox);
                    visualizeBitBox(cipher.currentBox);
                }
            });
            
            document.getElementById('mixColumnsBtn').addEventListener('click', function() {
                if (cipher.currentBox) {
                    cipher.currentBox = cipher.mixColumns(cipher.currentBox);
                    visualizeBitBox(cipher.currentBox);
                }
            });
            
            document.getElementById('addRoundKeyBtn').addEventListener('click', function() {
                if (cipher.currentBox) {
                    const key = document.getElementById('encryptionKey').value || 'defaultkey';
                    const roundKeys = cipher.generateRoundKeys(key);
                    cipher.currentBox = cipher.addRoundKey(cipher.currentBox, roundKeys[0]);
                    visualizeBitBox(cipher.currentBox);
                }
            });
            
            // Инициализация
            visualizeBitBox();
        });
    </script>
</body>
</html>
