<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D S-Box Crypto System</title>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #1e40af;
            --accent: #3b82f6;
            --dark: #1e293b;
            --light: #f8fafc;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, var(--accent), var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--primary);
        }
        
        .panel-header h2 {
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--accent);
        }
        
        textarea, input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(15, 23, 42, 0.6);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            color: var(--light);
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 20px 0;
        }
        
        button {
            padding: 14px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .result-area {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            border: 2px solid rgba(59, 130, 246, 0.3);
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-success {
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--success);
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error);
        }
        
        .status-warning {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: var(--warning);
        }
        
        /* Визуализация */
        .visualization {
            margin-top: 30px;
        }
        
        .rounds-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .round {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid var(--accent);
            transition: all 0.3s ease;
        }
        
        .round.active {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
        }
        
        .sbox-visualization {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .sbox-layer {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .sbox-title {
            text-align: center;
            margin-bottom: 10px;
            color: var(--accent);
            font-weight: 600;
        }
        
        .sbox-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
        }
        
        .sbox-cell {
            width: 20px;
            height: 20px;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .sbox-cell:hover {
            background: rgba(59, 130, 246, 0.3);
            transform: scale(1.3);
        }
        
        .sbox-cell.active {
            background: var(--primary);
            color: white;
            font-weight: bold;
        }
        
        .bit-visualization {
            margin-top: 25px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .bit-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .bit {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .bit.one {
            background: var(--primary);
            color: white;
        }
        
        .integrity-check {
            margin-top: 25px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .integrity-result {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
        }
        
        .integrity-valid {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
        }
        
        .integrity-invalid {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }
        
        .processing-animation {
            margin-top: 20px;
            height: 4px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }
        
        .processing-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            transition: width 0.5s ease;
        }
        
        .hash-display {
            margin-top: 20px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>3D S-Box Crypto System</h1>
            <p>Профессиональная система шифрования с полной визуализацией процесса</p>
        </header>

        <div class="main-grid">
            <!-- Панель управления -->
            <div class="panel">
                <div class="panel-header">
                    <h2>Управление шифрованием</h2>
                </div>
                
                <div class="form-group">
                    <label for="inputText">Исходный текст / Шифротекст:</label>
                    <textarea id="inputText" placeholder="Введите текст для шифрования или HEX-шифротекст для дешифрования..."></textarea>
                </div>
                
                <div class="form-group">
                    <label for="encryptionKey">Ключ шифрования (мин. 12 символов):</label>
                    <input type="password" id="encryptionKey" placeholder="Введите секретный ключ...">
                </div>
                
                <div class="btn-group">
                    <button class="btn-primary" onclick="startEncryption()">
                        <span>🔒</span> Зашифровать
                    </button>
                    <button class="btn-primary" onclick="startDecryption()">
                        <span>🔓</span> Расшифровать
                    </button>
                    <button class="btn-secondary" onclick="generateKey()">
                        <span>🎲</span> Сгенерировать ключ
                    </button>
                    <button class="btn-secondary" onclick="clearAll()">
                        <span>🧹</span> Очистить всё
                    </button>
                </div>
                
                <div class="result-area" id="resultArea">
                    Результаты операций будут отображены здесь...
                </div>
                
                <div class="status status-warning" id="statusMessage">
                    <span>⚠️</span> Система готова к работе. Введите данные для начала.
                </div>
                
                <div class="processing-animation">
                    <div class="processing-bar" id="processingBar"></div>
                </div>
            </div>
            
            <!-- Панель визуализации -->
            <div class="panel">
                <div class="panel-header">
                    <h2>Визуализация процесса</h2>
                </div>
                
                <div class="visualization">
                    <h3>Раунды шифрования</h3>
                    <div class="rounds-container" id="roundsContainer">
                        <!-- Раунды будут добавлены через JS -->
                    </div>
                    
                    <h3>3D S-Box преобразование</h3>
                    <div class="sbox-visualization">
                        <div class="sbox-layer">
                            <div class="sbox-title">S-Box X</div>
                            <div class="sbox-grid" id="sboxX">
                                <!-- Ячейки S-Box X -->
                            </div>
                        </div>
                        <div class="sbox-layer">
                            <div class="sbox-title">S-Box Y</div>
                            <div class="sbox-grid" id="sboxY">
                                <!-- Ячейки S-Box Y -->
                            </div>
                        </div>
                        <div class="sbox-layer">
                            <div class="sbox-title">S-Box Z</div>
                            <div class="sbox-grid" id="sboxZ">
                                <!-- Ячейки S-Box Z -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="bit-visualization">
                        <h3>Битовое представление</h3>
                        <div class="bit-grid" id="bitGrid">
                            <!-- Биты будут добавлены через JS -->
                        </div>
                    </div>
                    
                    <div class="integrity-check">
                        <h3>Проверка целостности</h3>
                        <div class="integrity-result" id="integrityResult">
                            <span>🔍</span> Проверка не проводилась
                        </div>
                    </div>
                    
                    <div class="hash-display" id="hashDisplay">
                        Хеш: _________________________
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Конфигурация системы
        const CONFIG = {
            ROUNDS: 12,
            KEY_MIN_LENGTH: 12,
            BLOCK_SIZE: 64,
            ANIMATION_DELAY: 100
        };
        
        // Глобальные переменные
        let currentRound = 0;
        let isProcessing = false;
        let sBoxSets = [];
        let integrityHash = '';
        
        // Инициализация визуализации
        function initializeVisualization() {
            // Создаем индикаторы раундов
            const roundsContainer = document.getElementById('roundsContainer');
            roundsContainer.innerHTML = '';
            
            for (let i = 1; i <= CONFIG.ROUNDS; i++) {
                const round = document.createElement('div');
                round.className = 'round';
                round.textContent = i;
                round.id = `round-${i}`;
                roundsContainer.appendChild(round);
            }
            
            // Инициализируем S-Box визуализацию
            initializeSBoxVisualization();
            
            // Инициализируем битовую визуализацию
            initializeBitVisualization();
        }
        
        // Инициализация S-Box визуализации
        function initializeSBoxVisualization() {
            const sboxX = document.getElementById('sboxX');
            const sboxY = document.getElementById('sboxY');
            const sboxZ = document.getElementById('sboxZ');
            
            sboxX.innerHTML = '';
            sboxY.innerHTML = '';
            sboxZ.innerHTML = '';
            
            for (let i = 0; i < 256; i++) {
                const cellX = createSBoxCell(i);
                const cellY = createSBoxCell(i);
                const cellZ = createSBoxCell(i);
                
                sboxX.appendChild(cellX);
                sboxY.appendChild(cellY);
                sboxZ.appendChild(cellZ);
            }
        }
        
        // Создание ячейки S-Box
        function createSBoxCell(value) {
            const cell = document.createElement('div');
            cell.className = 'sbox-cell';
            cell.textContent = value.toString(16).padStart(2, '0').toUpperCase();
            cell.title = `Значение: ${value}`;
            return cell;
        }
        
        // Инициализация битовой визуализации
        function initializeBitVisualization() {
            const bitGrid = document.getElementById('bitGrid');
            bitGrid.innerHTML = '';
            
            for (let i = 7; i >= 0; i--) {
                const bit = document.createElement('div');
                bit.className = 'bit';
                bit.textContent = '0';
                bit.dataset.bit = i;
                bitGrid.appendChild(bit);
            }
        }
        
        // Генерация S-Box на основе ключа
        function generateSBoxes(key) {
            sBoxSets = [];
            
            for (let round = 0; round < CONFIG.ROUNDS; round++) {
                const roundKey = key + round.toString();
                const seed = hashString(roundKey);
                
                const sBoxSet = {
                    x: generateSBoxLayer(seed),
                    y: generateSBoxLayer(seed + 1),
                    z: generateSBoxLayer(seed + 2)
                };
                
                sBoxSets.push(sBoxSet);
            }
            
            return sBoxSets;
        }
        
        // Генерация одного слоя S-Box
        function generateSBoxLayer(seed) {
            const sbox = new Array(256);
            for (let i = 0; i < 256; i++) sbox[i] = i;
            
            // Детерминированное перемешивание на основе seed
            let state = seed;
            for (let i = 255; i > 0; i--) {
                state = (state * 1664525 + 1013904223) % 4294967296;
                const j = state % (i + 1);
                [sbox[i], sbox[j]] = [sbox[j], sbox[i]];
            }
            
            return sbox;
        }
        
        // Хеширование строки
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash);
        }
        
        // Процесс шифрования
        async function encryptData(text, key) {
            if (isProcessing) return;
            isProcessing = true;
            
            try {
                updateStatus('Начало шифрования...', 'warning');
                updateProgress(0);
                
                // Генерируем S-Box
                generateSBoxes(key);
                updateProgress(10);
                
                // Преобразуем текст в байты
                const textBytes = new TextEncoder().encode(text);
                integrityHash = calculateHash(textBytes);
                updateHashDisplay(integrityHash);
                
                updateStatus('Применение 3D S-Box преобразований...', 'warning');
                
                const resultBytes = new Uint8Array(textBytes.length);
                
                // Проходим по всем раундам
                for (let round = 0; round < CONFIG.ROUNDS; round++) {
                    currentRound = round + 1;
                    updateRoundIndicator(currentRound);
                    updateProgress(10 + (round * 70 / CONFIG.ROUNDS));
                    
                    // Визуализируем текущий S-Box
                    visualizeSBoxes(round);
                    
                    // Обрабатываем каждый байт
                    for (let i = 0; i < textBytes.length; i++) {
                        let byte = textBytes[i];
                        
                        // Применяем S-Box преобразования
                        byte = sBoxSets[round].x[byte];
                        byte = sBoxSets[round].y[byte];
                        byte = sBoxSets[round].z[byte];
                        
                        resultBytes[i] = byte;
                        
                        // Визуализируем биты
                        if (i === 0) visualizeBits(byte);
                        
                        await delay(CONFIG.ANIMATION_DELAY / textBytes.length);
                    }
                    
                    await delay(300);
                }
                
                updateProgress(80);
                updateStatus('Формирование результата...', 'warning');
                
                // Конвертируем в HEX
                const hexResult = bytesToHex(resultBytes);
                
                updateProgress(100);
                updateStatus('Шифрование успешно завершено!', 'success');
                updateIntegrityCheck(true);
                
                return hexResult;
                
            } catch (error) {
                updateStatus(`Ошибка шифрования: ${error.message}`, 'error');
                return null;
            } finally {
                isProcessing = false;
            }
        }
        
        // Процесс дешифрования
        async function decryptData(hexData, key) {
            if (isProcessing) return;
            isProcessing = true;
            
            try {
                updateStatus('Начало дешифрования...', 'warning');
                updateProgress(0);
                
                // Генерируем S-Box
                generateSBoxes(key);
                updateProgress(10);
                
                // Конвертируем HEX в байты
                const encryptedBytes = hexToBytes(hexData);
                
                updateStatus('Применение обратных 3D S-Box преобразований...', 'warning');
                
                const resultBytes = new Uint8Array(encryptedBytes.length);
                
                // Проходим по всем раундам в обратном порядке
                for (let round = CONFIG.ROUNDS - 1; round >= 0; round--) {
                    currentRound = CONFIG.ROUNDS - round;
                    updateRoundIndicator(currentRound);
                    updateProgress(10 + ((CONFIG.ROUNDS - round - 1) * 70 / CONFIG.ROUNDS));
                    
                    // Визуализируем текущий S-Box
                    visualizeSBoxes(round);
                    
                    // Обрабатываем каждый байт
                    for (let i = 0; i < encryptedBytes.length; i++) {
                        let byte = encryptedBytes[i];
                        
                        // Применяем обратные S-Box преобразования
                        byte = sBoxSets[round].z.indexOf(byte);
                        byte = sBoxSets[round].y.indexOf(byte);
                        byte = sBoxSets[round].x.indexOf(byte);
                        
                        resultBytes[i] = byte;
                        
                        // Визуализируем биты
                        if (i === 0) visualizeBits(byte);
                        
                        await delay(CONFIG.ANIMATION_DELAY / encryptedBytes.length);
                    }
                    
                    await delay(300);
                }
                
                updateProgress(80);
                updateStatus('Проверка целостности...', 'warning');
                
                // Проверяем целостность
                const currentHash = calculateHash(resultBytes);
                const integrityValid = currentHash === integrityHash;
                
                updateProgress(100);
                
                if (integrityValid) {
                    updateStatus('Дешифрование успешно завершено!', 'success');
                    updateIntegrityCheck(true);
                    return new TextDecoder().decode(resultBytes);
                } else {
                    updateStatus('Ошибка целостности данных!', 'error');
                    updateIntegrityCheck(false);
                    return null;
                }
                
            } catch (error) {
                updateStatus(`Ошибка дешифрования: ${error.message}`, 'error');
                return null;
            } finally {
                isProcessing = false;
            }
        }
        
        // Вспомогательные функции
        function bytesToHex(bytes) {
            return Array.from(bytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }
        
        function calculateHash(bytes) {
            let hash = 0;
            for (const byte of bytes) {
                hash = ((hash << 5) - hash) + byte;
                hash |= 0;
            }
            return hash.toString(16).padStart(8, '0');
        }
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // Функции обновления UI
        function updateStatus(message, type) {
            const status = document.getElementById('statusMessage');
            status.className = `status status-${type}`;
            
            let icon = '⚠️';
            if (type === 'success') icon = '✅';
            if (type === 'error') icon = '❌';
            
            status.innerHTML = `<span>${icon}</span> ${message}`;
        }
        
        function updateProgress(percent) {
            const bar = document.getElementById('processingBar');
            bar.style.width = `${percent}%`;
        }
        
        function updateRoundIndicator(round) {
            // Сбрасываем все раунды
            document.querySelectorAll('.round').forEach(r => {
                r.classList.remove('active');
            });
            
            // Активируем текущий раунд
            const currentRoundElement = document.getElementById(`round-${round}`);
            if (currentRoundElement) {
                currentRoundElement.classList.add('active');
            }
        }
        
        function visualizeSBoxes(roundIndex) {
            if (roundIndex >= sBoxSets.length) return;
            
            const sboxSet = sBoxSets[roundIndex];
            
            // Обновляем S-Box визуализацию
            updateSBoxLayer('sboxX', sboxSet.x);
            updateSBoxLayer('sboxY', sboxSet.y);
            updateSBoxLayer('sboxZ', sboxSet.z);
        }
        
        function updateSBoxLayer(layerId, sbox) {
            const layer = document.getElementById(layerId);
            const cells = layer.querySelectorAll('.sbox-cell');
            
            for (let i = 0; i < Math.min(sbox.length, cells.length); i++) {
                cells[i].textContent = sbox[i].toString(16).padStart(2, '0').toUpperCase();
                cells[i].title = `Индекс: ${i.toString(16).padStart(2, '0').toUpperCase()}\nЗначение: ${sbox[i].toString(16).padStart(2, '0').toUpperCase()}`;
            }
        }
        
        function visualizeBits(byte) {
            const bits = document.querySelectorAll('.bit');
            
            for (let i = 0; i < 8; i++) {
                const bitValue = (byte >> (7 - i)) & 1;
                bits[i].textContent = bitValue;
                bits[i].className = `bit ${bitValue ? 'one' : ''}`;
            }
        }
        
        function updateIntegrityCheck(isValid) {
            const integrityResult = document.getElementById('integrityResult');
            integrityResult.className = `integrity-result ${isValid ? 'integrity-valid' : 'integrity-invalid'}`;
            
            if (isValid) {
                integrityResult.innerHTML = '<span>✅</span> Целостность данных подтверждена';
            } else {
                integrityResult.innerHTML = '<span>❌</span> Нарушение целостности данных!';
            }
        }
        
        function updateHashDisplay(hash) {
            document.getElementById('hashDisplay').textContent = `Хеш: ${hash}`;
        }
        
        function updateResult(content) {
            document.getElementById('resultArea').textContent = content;
        }
        
        // Обработчики действий
        async function startEncryption() {
            const text = document.getElementById('inputText').value;
            const key = document.getElementById('encryptionKey').value;
            
            if (!text) {
                updateStatus('Введите текст для шифрования', 'error');
                return;
            }
            
            if (!key || key.length < CONFIG.KEY_MIN_LENGTH) {
                updateStatus(`Ключ должен содержать минимум ${CONFIG.KEY_MIN_LENGTH} символов`, 'error');
                return;
            }
            
            initializeVisualization();
            const result = await encryptData(text, key);
            
            if (result) {
                updateResult(`Зашифрованный текст (HEX):\n${result}`);
            }
        }
        
        async function startDecryption() {
            const text = document.getElementById('inputText').value;
            const key = document.getElementById('encryptionKey').value;
            
            if (!text) {
                updateStatus('Введите шифротекст для дешифрования', 'error');
                return;
            }
            
            if (!key || key.length < CONFIG.KEY_MIN_LENGTH) {
                updateStatus(`Ключ должен содержать минимум ${CONFIG.KEY_MIN_LENGTH} символов`, 'error');
                return;
            }
            
            // Проверяем, что ввод выглядит как HEX
            if (!/^[0-9a-fA-F]+$/.test(text)) {
                updateStatus('Введите корректный HEX-шифротекст', 'error');
                return;
            }
            
            initializeVisualization();
            const result = await decryptData(text, key);
            
            if (result) {
                updateResult(`Расшифрованный текст:\n${result}`);
            }
        }
        
        function generateKey() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_-+=[]{}|;:,.<>?';
            let key = '';
            
            for (let i = 0; i < 24; i++) {
                key += chars[Math.floor(Math.random() * chars.length)];
            }
            
            document.getElementById('encryptionKey').value = key;
            updateStatus('Сгенерирован новый ключ', 'success');
        }
        
        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('encryptionKey').value = '';
            document.getElementById('resultArea').textContent = 'Результаты операций будут отображены здесь...';
            updateStatus('Все поля очищены. Система готова к работе.', 'warning');
            initializeVisualization();
        }
        
        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', function() {
            initializeVisualization();
            generateKey();
        });
    </script>
</body>
</html>
