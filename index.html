<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureCrypt Pro - Military-Grade Encryption</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/argon2-browser@1.18.0/lib/argon2.js"></script>
    <style>
        /* Оптимизированные стили */
        :root {
            --bg-primary: #0f0f12;
            --bg-secondary: #1e1e24;
            --bg-tertiary: #2c2c35;
            --accent-blue: #3a7bf7;
            --accent-green: #30d158;
            --accent-purple: #bf5af2;
            --accent-red: #ff453a;
            --accent-orange: #ff9f0a;
            --text-primary: #f5f5f7;
            --text-secondary: #a1a1a6;
            --border-radius: 16px;
            --border-color: #3a3a44;
            --font-sans: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            --font-mono: 'SF Mono', Menlo, monospace;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* Остальные стили остаются без изменений */
        /* ... существующие стили ... */

        /* Новые элементы */
        .progress-bar {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(to right, var(--accent-purple), var(--accent-blue));
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .key-visualizer {
            display: flex;
            gap: 2px;
            height: 8px;
            margin-top: 8px;
        }
        
        .key-segment {
            flex: 1;
            background: var(--bg-tertiary);
            border-radius: 2px;
        }
        
        .history-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .history-item:hover {
            background: #333340;
        }
        
        .key-action {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .key-action-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255,255,255,0.08);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .key-action-btn:hover {
            background: rgba(255,255,255,0.15);
        }
        
        .security-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
        }
        
        .security-high {
            background: rgba(48, 209, 88, 0.15);
            color: var(--accent-green);
        }
        
        .security-medium {
            background: rgba(255, 159, 10, 0.15);
            color: var(--accent-orange);
        }
        
        .security-low {
            background: rgba(255, 69, 58, 0.15);
            color: var(--accent-red);
        }
        
        .operations-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,69,58,0.2);
            color: var(--accent-red);
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="window">
            <div class="operations-counter" id="attempt-counter">Попыток: 0/5</div>
            
            <div class="title-bar">
                <div class="logo">
                    <div class="logo-icon">
                        <i class="fas fa-lock"></i>
                    </div>
                    <h1>SecureCrypt Pro</h1>
                </div>
                <div class="badge">
                    <i class="fas fa-shield-alt"></i>
                    AES-256-GCM | Argon2id | Military-Grade
                </div>
            </div>

            <div class="tabs">
                <div class="tab active" onclick="switchTab('encrypt')">
                    <i class="fas fa-lock"></i> Шифрование
                </div>
                <div class="tab" onclick="switchTab('decrypt')">
                    <i class="fas fa-unlock"></i> Дешифрование
                </div>
                <div class="tab" onclick="switchTab('settings')">
                    <i class="fas fa-cog"></i> Настройки
                </div>
                <div class="tab" onclick="switchTab('history')">
                    <i class="fas fa-history"></i> История
                </div>
            </div>

            <div id="encrypt-panel" class="panel active">
                <div class="card">
                    <div class="card-header">
                        <h2><i class="fas fa-key"></i> Шифрование текста</h2>
                        <div class="key-action">
                            <div class="key-action-btn" onclick="generateStrongPassword()">
                                <i class="fas fa-key"></i> Сгенерировать ключ
                            </div>
                            <div class="key-action-btn" onclick="saveKeyToFile()">
                                <i class="fas fa-save"></i> Экспорт ключа
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="encrypt-key">Ключ шифрования <span id="key-strength-badge" class="security-badge security-low">Слабый</span></label>
                        <input type="password" id="encrypt-key" placeholder="Введите секретный ключ (минимум 12 символов)" 
                               oninput="updateEntropyMeter(this.value)">
                        <div class="key-visualizer" id="key-visualizer">
                            <div class="key-segment"></div>
                            <div class="key-segment"></div>
                            <div class="key-segment"></div>
                            <div class="key-segment"></div>
                            <div class="key-segment"></div>
                            <div class="key-segment"></div>
                        </div>
                        <div class="entropy-meter">
                            <div class="entropy-level" id="entropy-level"></div>
                        </div>
                        <div class="security-indicator">
                            <div class="indicator-dot" id="security-dot"></div>
                            <span id="security-text">Введите пароль</span>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="plain-text">Текст для шифрования</label>
                        <textarea id="plain-text" placeholder="Введите конфиденциальный текст...">Тестовый текст для шифрования</textarea>
                    </div>
                    
                    <div class="settings-row">
                        <div class="form-group">
                            <label for="output-format">Формат вывода:</label>
                            <select id="output-format">
                                <option value="base64">Base64 (стандартный)</option>
                                <option value="hex">HEX (шестнадцатеричный)</option>
                                <option value="numeric">Числовой</option>
                                <option value="alpha">Буквенный</option>
                                <option value="matrix">Матричный</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="key-derivation">Деривация ключа:</label>
                            <select id="key-derivation">
                                <option value="argon2">Argon2id (рекомендуется)</option>
                                <option value="pbkdf2">PBKDF2 (совместимость)</option>
                            </select>
                        </div>
                    </div>

                    <button id="encrypt-btn" onclick="encryptText()">
                        <i class="fas fa-lock"></i>
                        Зашифровать
                    </button>
                    
                    <div class="progress-bar">
                        <div class="progress" id="encrypt-progress"></div>
                    </div>

                    <div class="result-container">
                        <div class="result-label">
                            <i class="fas fa-file-code"></i>
                            Результат шифрования
                        </div>
                        <div class="result" id="encrypted-result">Здесь появится зашифрованный текст...</div>
                        <div class="result-actions">
                            <div class="action-btn" onclick="copyResult('encrypted-result')">
                                <i class="fas fa-copy"></i> Копировать
                            </div>
                            <div class="action-btn" onclick="downloadResult()">
                                <i class="fas fa-download"></i> Сохранить
                            </div>
                            <div class="action-btn" onclick="clearResult('encrypted-result')">
                                <i class="fas fa-trash"></i> Очистить
                            </div>
                        </div>
                    </div>
                    
                    <div class="status hidden" id="encrypt-status">
                        <span class="error-message"></span>
                        <div class="error-details" id="encrypt-error-details"></div>
                    </div>
                </div>
            </div>

            <!-- Остальные панели (decrypt, settings) остаются аналогичными -->
            <!-- ... существующие панели ... -->
            
            <div id="history-panel" class="panel">
                <div class="card">
                    <div class="card-header">
                        <h2><i class="fas fa-history"></i> История операций</h2>
                    </div>
                    
                    <div class="form-group">
                        <label>Последние операции:</label>
                        <div id="operations-history">
                            <!-- История будет добавляться динамически -->
                        </div>
                    </div>
                    
                    <button class="btn-secondary" onclick="clearHistory()">
                        <i class="fas fa-trash"></i>
                        Очистить историю
                    </button>
                </div>
            </div>

            <div class="footer">
                <p>SecureCrypt Pro v8.1 | Military-Grade AES-256-GCM | Argon2id | © 2026</p>
                <p>Все операции выполняются локально в вашем браузере | Нет трекеров | Нет сбора данных</p>
            </div>
        </div>
    </div>

    <script>
        // Конфигурация безопасности
        const SECURITY_CONFIG = {
            maxAttempts: 5,
            blockTime: 300000, // 5 минут
            minKeyLength: 16
        };

        // Расширенные настройки
        let settings = {
            argonIterations: 5,
            argonMemory: 128,
            autoClear: 30,
            keyDerivation: 'argon2',
            historyLimit: 20
        };

        // Безопасное хранилище ключей
        let keyCache = {
            encryptKey: null,
            decryptKey: null,
            cacheTime: 0,
            cacheDuration: 30000 // 30 секунд
        };

        // История операций
        let operationsHistory = [];
        
        // Счетчик попыток
        let decryptAttempts = 0;
        let blockedUntil = 0;

        // Расширенные форматы данных
        const safeFormats = {
            base64: {
                encode: (data) => btoa(String.fromCharCode(...new Uint8Array(data))),
                decode: (str) => {
                    try {
                        return Uint8Array.from(atob(str), c => c.charCodeAt(0));
                    } catch (e) {
                        throw new Error("Некорректный формат Base64");
                    }
                }
            },
            
            hex: {
                encode: (data) => Array.from(new Uint8Array(data)).map(b => 
                    b.toString(16).padStart(2, '0')).join(''),
                decode: (hex) => {
                    if (hex.length % 2 !== 0) {
                        throw new Error("Некорректная HEX строка (нечетная длина)");
                    }
                    
                    const bytes = new Uint8Array(hex.length / 2);
                    for (let i = 0; i < bytes.length; i++) {
                        const byte = parseInt(hex.substr(i*2, 2), 16);
                        if (isNaN(byte)) {
                            throw new Error(`Некорректный HEX символ в позиции ${i*2}`);
                        }
                        bytes[i] = byte;
                    }
                    return bytes;
                }
            },
            
            numeric: {
                encode: (data) => {
                    const bytes = new Uint8Array(data);
                    return Array.from(bytes)
                        .map(b => b.toString().padStart(3, '0'))
                        .join(' ');
                },
                decode: (str) => {
                    const parts = str.split(' ');
                    const bytes = new Uint8Array(parts.length);
                    
                    for (let i = 0; i < parts.length; i++) {
                        const num = parseInt(parts[i], 10);
                        if (isNaN(num) {
                            throw new Error(`Некорректное число: ${parts[i]}`);
                        }
                        if (num < 0 || num > 255) {
                            throw new Error(`Число вне диапазона: ${num} (должно быть 0-255)`);
                        }
                        bytes[i] = num;
                    }
                    return bytes;
                }
            },
            
            alpha: {
                encode: (data) => {
                    const bytes = new Uint8Array(data);
                    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                    let result = '';
                    
                    for (let i = 0; i < bytes.length; i++) {
                        result += alphabet[bytes[i] % alphabet.length];
                    }
                    
                    return result;
                },
                decode: (str) => {
                    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                    const bytes = new Uint8Array(str.length);
                    
                    for (let i = 0; i < str.length; i++) {
                        const char = str[i].toUpperCase();
                        const index = alphabet.indexOf(char);
                        
                        if (index === -1) {
                            throw new Error(`Недопустимый символ: ${char}`);
                        }
                        
                        bytes[i] = index;
                    }
                    
                    return bytes;
                }
            },
            
            matrix: {
                encode: (data) => {
                    const bytes = new Uint8Array(data);
                    const size = Math.ceil(Math.sqrt(bytes.length));
                    let result = '';
                    
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const index = i * size + j;
                            result += index < bytes.length ? 
                                bytes[index].toString(16).padStart(2, '0') + ' ' : '00 ';
                        }
                        result = result.trim() + '\n';
                    }
                    return result.trim();
                },
                decode: (str) => {
                    const lines = str.split('\n');
                    const size = lines.length;
                    const bytes = new Uint8Array(size * size);
                    let index = 0;
                    
                    for (let i = 0; i < size; i++) {
                        const hexValues = lines[i].split(' ');
                        for (let j = 0; j < hexValues.length; j++) {
                            if (hexValues[j]) {
                                const byte = parseInt(hexValues[j], 16);
                                if (isNaN(byte)) {
                                    throw new Error(`Некорректный HEX байт: ${hexValues[j]}`);
                                }
                                bytes[index++] = byte;
                            }
                        }
                    }
                    
                    return bytes.slice(0, index);
                }
            }
        };

        // Инициализация
        window.onload = function() {
            loadSettings();
            loadSecurityState();
            loadHistory();
            updateSecurityUI();
            
            // Проверка поддержки Web Crypto API
            if (!window.crypto || !crypto.subtle) {
                showStatus("Ваш браузер не поддерживает необходимые криптографические функции", "encrypt-status", false);
            }
            
            // Проверка Argon2
            if (typeof argon2 === 'undefined') {
                showStatus("Библиотека Argon2 не загружена", "encrypt-status", false);
            }
        };

        // Загрузка настроек
        function loadSettings() {
            const savedSettings = localStorage.getItem('secureCryptSettings');
            if (savedSettings) {
                try {
                    settings = JSON.parse(savedSettings);
                    applySettings();
                } catch (e) {
                    console.error("Ошибка загрузки настроек:", e);
                }
            }
        }

        // Применение настроек
        function applySettings() {
            document.getElementById('argon-iterations').value = settings.argonIterations;
            document.getElementById('argon-memory').value = settings.argonMemory;
            document.getElementById('key-strength').value = settings.minKeyLength || 16;
            document.getElementById('auto-clear').value = settings.autoClear || 30;
            document.getElementById('key-derivation').value = settings.keyDerivation || 'argon2';
        }

        // Сохранение настроек
        function saveSettings() {
            settings.argonIterations = parseInt(document.getElementById('argon-iterations').value);
            settings.argonMemory = parseInt(document.getElementById('argon-memory').value);
            settings.minKeyLength = parseInt(document.getElementById('key-strength').value);
            settings.autoClear = parseInt(document.getElementById('auto-clear').value);
            settings.keyDerivation = document.getElementById('key-derivation').value;
            
            localStorage.setItem('secureCryptSettings', JSON.stringify(settings));
            showStatus("Настройки сохранены", "settings-status", true);
        }

        // Загрузка состояния безопасности
        function loadSecurityState() {
            const securityData = localStorage.getItem('securityData');
            if (securityData) {
                try {
                    const data = JSON.parse(securityData);
                    decryptAttempts = data.attempts || 0;
                    blockedUntil = data.blockedUntil || 0;
                } catch (e) {
                    console.error("Ошибка загрузки состояния безопасности:", e);
                }
            }
        }

        // Сохранение состояния безопасности
        function saveSecurityState() {
            const securityData = JSON.stringify({
                attempts: decryptAttempts,
                blockedUntil: blockedUntil
            });
            localStorage.setItem('securityData', securityData);
        }

        // Загрузка истории
        function loadHistory() {
            const history = localStorage.getItem('operationsHistory');
            if (history) {
                try {
                    operationsHistory = JSON.parse(history) || [];
                    renderHistory();
                } catch (e) {
                    console.error("Ошибка загрузки истории:", e);
                }
            }
        }

        // Сохранение истории
        function saveHistory() {
            localStorage.setItem('operationsHistory', JSON.stringify(operationsHistory));
        }

        // Отрисовка истории
        function renderHistory() {
            const container = document.getElementById('operations-history');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (operationsHistory.length === 0) {
                container.innerHTML = '<div class="history-item">История операций пуста</div>';
                return;
            }
            
            operationsHistory.slice(0, settings.historyLimit).forEach((op, index) => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <div><strong>${op.type === 'encrypt' ? 'Шифрование' : 'Дешифрование'}</strong></div>
                    <div>${new Date(op.timestamp).toLocaleString()}</div>
                    <div class="text-secondary">${op.data.substring(0, 40)}${op.data.length > 40 ? '...' : ''}</div>
                `;
                
                item.onclick = () => {
                    if (op.type === 'encrypt') {
                        document.getElementById('cipher-text').value = op.data;
                        switchTab('decrypt');
                    } else {
                        document.getElementById('plain-text').value = op.data;
                        switchTab('encrypt');
                    }
                };
                
                container.appendChild(item);
            });
        }

        // Добавление операции в историю
        function addToHistory(type, data) {
            operationsHistory.unshift({
                type: type,
                data: data.substring(0, 500),
                timestamp: Date.now()
            });
            
            // Сохраняем только последние N операций
            if (operationsHistory.length > settings.historyLimit) {
                operationsHistory = operationsHistory.slice(0, settings.historyLimit);
            }
            
            saveHistory();
            renderHistory();
        }

        // Очистка истории
        function clearHistory() {
            operationsHistory = [];
            saveHistory();
            renderHistory();
            showStatus("История очищена", "settings-status", true);
        }

        // Обновление UI безопасности
        function updateSecurityUI() {
            const counter = document.getElementById('attempt-counter');
            
            if (blockedUntil > Date.now()) {
                const timeLeft = Math.ceil((blockedUntil - Date.now()) / 1000);
                counter.textContent = `Заблокировано (${timeLeft}с)`;
                counter.style.display = 'block';
                return;
            }
            
            if (decryptAttempts > 0) {
                counter.textContent = `Попыток: ${decryptAttempts}/${SECURITY_CONFIG.maxAttempts}`;
                counter.style.display = 'block';
            } else {
                counter.style.display = 'none';
            }
        }

        // Генерация сильного пароля
        function generateStrongPassword() {
            const length = Math.max(16, settings.minKeyLength);
            const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
            let password = "";
            
            // Гарантируем наличие разных категорий символов
            password += getRandomChar("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
            password += getRandomChar("abcdefghijklmnopqrstuvwxyz");
            password += getRandomChar("0123456789");
            password += getRandomChar("!@#$%^&*()_+-=[]{}|;:,.<>?");
            
            // Дополняем до нужной длины
            for (let i = password.length; i < length; i++) {
                password += getRandomChar(charset);
            }
            
            // Перемешиваем
            password = password.split('').sort(() => Math.random() - 0.5).join('');
            
            document.getElementById('encrypt-key').value = password;
            updateEntropyMeter(password);
        }
        
        function getRandomChar(charset) {
            return charset.charAt(Math.floor(Math.random() * charset.length));
        }

        // Экспорт ключа в файл
        function saveKeyToFile() {
            const key = document.getElementById('encrypt-key').value;
            if (!key) {
                showStatus("Сначала введите ключ", "encrypt-status", false);
                return;
            }
            
            const blob = new Blob([key], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'securecrypt_key.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Шифрование текста (оптимизированная версия)
        async function encryptText() {
            const text = document.getElementById('plain-text').value;
            const key = document.getElementById('encrypt-key').value;
            const format = document.getElementById('output-format').value;
            const derivation = document.getElementById('key-derivation').value;
            
            // Сброс статуса
            document.getElementById('encrypt-status').classList.add('hidden');
            
            // Проверка блокировки
            if (blockedUntil > Date.now()) {
                const timeLeft = Math.ceil((blockedUntil - Date.now()) / 1000);
                showStatus(`Система заблокирована. Попробуйте через ${timeLeft} секунд`, "encrypt-status", false);
                return;
            }
            
            // Базовые проверки
            if (!text || !key) {
                showStatus("Ошибка: нужен текст и ключ", "encrypt-status", false);
                return;
            }

            const minLength = settings.minKeyLength || 16;
            if (key.length < minLength) {
                showStatus(`Ключ должен быть не менее ${minLength} символов`, "encrypt-status", false);
                return;
            }

            try {
                const resultElement = document.getElementById('encrypted-result');
                const progressBar = document.getElementById('encrypt-progress');
                const btn = document.getElementById('encrypt-btn');
                
                // Блокировка кнопки
                btn.disabled = true;
                resultElement.innerHTML = '<span class="loader"></span> Шифрование...';
                
                // Параметры
                const params = {
                    argonIterations: settings.argonIterations,
                    argonMemory: settings.argonMemory,
                    minKeyLength: minLength,
                    keyDerivation: derivation
                };
                
                // Обновление прогресса
                const updateProgress = (percent) => {
                    progressBar.style.width = `${percent}%`;
                };
                
                updateProgress(10);
                
                // Шифрование
                const encryptedData = await secureEncrypt(text, key, params, updateProgress);
                updateProgress(90);
                
                // Форматирование результата
                const formattedResult = safeFormats[format].encode(encryptedData);
                
                // Обновление UI
                resultElement.textContent = formattedResult;
                resultElement.className = 'result';
                
                // Применяем стили формата
                if (format === 'hex') resultElement.classList.add('hex-format');
                if (format === 'numeric') resultElement.classList.add('numeric-format');
                if (format === 'alpha') resultElement.classList.add('alpha-format');
                if (format === 'matrix') resultElement.classList.add('matrix-format');
                
                updateProgress(100);
                showStatus("Текст успешно зашифрован", "encrypt-status", true);
                addToHistory('encrypt', formattedResult);
                
                // Автоочистка
                if (settings.autoClear > 0) {
                    setTimeout(() => {
                        document.getElementById('encrypt-key').value = '';
                        showStatus("Ключ очищен для безопасности", "encrypt-status", true);
                    }, settings.autoClear * 1000);
                }
            } catch (e) {
                showStatus("Ошибка шифрования", "encrypt-status", false, e.message);
                document.getElementById('encrypted-result').textContent = "Ошибка шифрования";
            } finally {
                document.getElementById('encrypt-btn').disabled = false;
            }
        }

        // Оптимизированное шифрование
        async function secureEncrypt(text, password, params, progressCallback) {
            // ... реализация аналогична предыдущей, но с вызовами progressCallback ...
            // Добавлены вызовы progressCallback в ключевых точках
        }

        // Обработка ошибок дешифрования
        async function decryptText() {
            // ... существующая реализация ...
            
            try {
                // ... попытка дешифрования ...
                
                // При успехе
                decryptAttempts = 0;
                saveSecurityState();
                updateSecurityUI();
                
            } catch (e) {
                decryptAttempts++;
                
                if (decryptAttempts >= SECURITY_CONFIG.maxAttempts) {
                    blockedUntil = Date.now() + SECURITY_CONFIG.blockTime;
                    showStatus(`Слишком много попыток. Система заблокирована до ${new Date(blockedUntil).toLocaleTimeString()}`, "decrypt-status", false);
                } else {
                    showStatus(`Неверный ключ (попытка ${decryptAttempts}/${SECURITY_CONFIG.maxAttempts})`, "decrypt-status", false, e.message);
                }
                
                saveSecurityState();
                updateSecurityUI();
            }
        }

        // Визуализатор ключа
        function updateEntropyMeter(password) {
            // ... существующая реализация ...
            
            // Обновление визуализатора
            const visualizer = document.getElementById('key-visualizer');
            const segments = visualizer.querySelectorAll('.key-segment');
            const badge = document.getElementById('key-strength-badge');
            
            let strengthClass = '';
            let strengthText = '';
            
            if (entropyPercent < 30) {
                strengthClass = 'security-low';
                strengthText = 'Слабый';
            } else if (entropyPercent < 70) {
                strengthClass = 'security-medium';
                strengthText = 'Средний';
            } else {
                strengthClass = 'security-high';
                strengthText = 'Сильный';
            }
            
            // Обновление бейджа
            badge.className = `security-badge ${strengthClass}`;
            badge.textContent = strengthText;
            
            // Обновление сегментов
            const activeSegments = Math.ceil(entropyPercent / 100 * segments.length);
            
            segments.forEach((seg, i) => {
                if (i < activeSegments) {
                    seg.style.background = getSegmentColor(i, activeSegments);
                } else {
                    seg.style.background = '';
                }
            });
        }
        
        function getSegmentColor(index, total) {
            const hue = Math.floor(120 * (index / total)); // 0-120 (красный-зеленый)
            return `hsl(${hue}, 80%, 60%)`;
        }

        // Очистка конфиденциальных данных из памяти
        function secureWipe(buffer) {
            if (buffer instanceof ArrayBuffer) {
                const view = new Uint8Array(buffer);
                for (let i = 0; i < view.length; i++) {
                    view[i] = 0;
                }
            } else if (typeof buffer === 'string') {
                // Строки неизменяемы, поэтому создаем новый буфер
                const encoder = new TextEncoder();
                const buffer = encoder.encode(buffer);
                for (let i = 0; i < buffer.length; i++) {
                    buffer[i] = 0;
                }
            }
        }
    </script>
</body>
</html>
